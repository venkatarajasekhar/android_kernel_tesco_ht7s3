/*
 * Driver for OV5642 CMOS Image Sensor from OmniVision
 *
 * Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <linux/videodev2.h>
#include <linux/slab.h>
#include <linux/i2c.h>
#include <linux/log2.h>
#include <linux/platform_device.h>
#include <linux/delay.h>
#include <linux/circ_buf.h>
#include <linux/hardirq.h>
#include <linux/miscdevice.h>
#include <media/v4l2-common.h>
#include <media/v4l2-chip-ident.h>
#include <media/soc_camera.h>
#include <plat/rk_camera.h>
#include "mt9t113.h"

static int debug=0;

module_param(debug, int, S_IRUGO|S_IWUSR);

#define dprintk(level, fmt, arg...) do {			\
	if (debug >= level) 					\
	printk(KERN_WARNING fmt , ## arg); } while (0)

#define SENSOR_TR(format, ...) printk(KERN_ERR format, ## __VA_ARGS__)
#define SENSOR_DG(format, ...) dprintk(1, format, ## __VA_ARGS__)

#define _CONS(a,b) a##b
#define CONS(a,b) _CONS(a,b)

#define __STR(x) #x
#define _STR(x) __STR(x)
#define STR(x) _STR(x)

#define MIN(x,y)   ((x<y) ? x: y)
#define MAX(x,y)    ((x>y) ? x: y)

/* Sensor Driver Configuration */
#define SENSOR_NAME RK29_CAM_SENSOR_MT9T113
#define SENSOR_V4L2_IDENT V4L2_IDENT_MT9T113
#define SENSOR_ID 0x4680 //SEQUENCE_END
#define SENSOR_ID_REG 0x0000 //SEQUENCE_END //0x00
#define SENSOR_RESET_REG SEQUENCE_END
#define SENSOR_RESET_VAL SEQUENCE_END
#define SENSOR_RESET_REG_LEN  WORD_LEN
#define SENSOR_MIN_WIDTH    176
#define SENSOR_MIN_HEIGHT   144
#define SENSOR_MAX_WIDTH    2048
#define SENSOR_MAX_HEIGHT   1536
#define SENSOR_INIT_WIDTH	1280			/* Sensor pixel size for sensor_init_data array */
#define SENSOR_INIT_HEIGHT  720
#define SENSOR_INIT_WINSEQADR sensor_uxga //sensor_init_data
#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8

#define CONFIG_SENSOR_WhiteBalance	1
#define CONFIG_SENSOR_Brightness	0
#define CONFIG_SENSOR_Contrast      0
#define CONFIG_SENSOR_Saturation    0
#define CONFIG_SENSOR_Effect        1
#define CONFIG_SENSOR_Scene         1
#define CONFIG_SENSOR_DigitalZoom   0
#define CONFIG_SENSOR_Exposure      1
#define CONFIG_SENSOR_Flash         1
#define CONFIG_SENSOR_Mirror        0
#define CONFIG_SENSOR_Flip          0
#define CONFIG_SENSOR_Focus         1

/*Sensor write registers at a time*/
#define CONFIG_SENSOR_WRITE_REGS  0


#define CONFIG_SENSOR_I2C_SPEED     300000       /* Hz */
/* Sensor write register continues by preempt_disable/preempt_enable for current process not be scheduled */
#define CONFIG_SENSOR_I2C_NOSCHED   0
#define CONFIG_SENSOR_I2C_RDWRCHK  0


#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|\
                          SOCAM_HSYNC_ACTIVE_HIGH| SOCAM_VSYNC_ACTIVE_HIGH|\
                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)

#define COLOR_TEMPERATURE_CLOUDY_DN    6500
#define COLOR_TEMPERATURE_CLOUDY_UP    8000
#define COLOR_TEMPERATURE_CLEARDAY_DN  5000
#define COLOR_TEMPERATURE_CLEARDAY_UP    6500
#define COLOR_TEMPERATURE_OFFICE_DN     3500
#define COLOR_TEMPERATURE_OFFICE_UP     5000
#define COLOR_TEMPERATURE_HOME_DN       2500
#define COLOR_TEMPERATURE_HOME_UP       3500

#define SENSOR_NAME_STRING(a) STR(CONS(SENSOR_NAME, a))
#define SENSOR_NAME_VARFUN(a) CONS(SENSOR_NAME, a)

#define SENSOR_AF_IS_ERR    (0x00<<0)
#define SENSOR_AF_IS_OK		(0x01<<0)
#define SENSOR_INIT_IS_ERR   (0x00<<28)
#define SENSOR_INIT_IS_OK    (0x01<<28)

#if CONFIG_SENSOR_Focus
#define SENSOR_AF_MODE_INFINITY    0
#define SENSOR_AF_MODE_MACRO       1
#define SENSOR_AF_MODE_FIXED       2
#define SENSOR_AF_MODE_AUTO        3
#define SENSOR_AF_MODE_CONTINUOUS  4
#define SENSOR_AF_MODE_CLOSE       5
#endif

//flash off in fixed time to prevent from too hot , zyc
struct  flash_timer{
    struct soc_camera_device *icd;
	struct hrtimer timer;
};
static enum hrtimer_restart flash_off_func(struct hrtimer *timer);

static struct  flash_timer flash_off_timer;
//for user defined if user want to customize the series , zyc
#ifdef CONFIG_MT9T113_USER_DEFINED_SERIES
#include "mt9t113_user_series.c"
#else

static struct reginfo sensor_init_data[] =
{
#if 1
// 24M Mclk, 96M Pclk, 640x480 @30fps, 2048x1536 @7.32fps
	{0x0018, 0x4129, WORD_LEN, 0 },// TANDBY_CONTROL_AND_STATUS
	{SEQUENCE_WAIT_MS,100, WORD_LEN, 0},
	{0x0018, 0x4029, WORD_LEN, 0 },// STANDBY_CONTROL_AND_STATUS
	{SEQUENCE_WAIT_MS,100, WORD_LEN, 0},
	{0x0010, 0x0010, WORD_LEN, 0 },  	// PLL_CONTROL
	{0x0012, 0x0070, WORD_LEN, 0 },// PLL_P_DIVIDERS
	{0x002A, 0x78DA, WORD_LEN, 0 },  	// PLL_CONTROL
	{0x0018, 0x402E, WORD_LEN, 0 },  	// PLL_DIVIDERS//31E
	{SEQUENCE_WAIT_MS,50, WORD_LEN, 0},

//	{0x0022, 0x0140, WORD_LEN, 0 },  	// PLL_P4_P5_P6_DIVIDERS//7EFF
	{0x001E, 0x0777, WORD_LEN, 0 },  	// RESET_AND_MISC_CONTROL
//	{0x3B84, 0x0062, WORD_LEN, 0 },  	// PLL_CONTROL

	{0x0018, 0x4028, WORD_LEN, 0 },  	// PLL_DIVIDERS//31E

//	{0x0990, 0x0000, WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x4800, WORD_LEN, 0 },// y_start
	{0x0990, 0x0010, WORD_LEN, 0 },//	   = 16
	{0x098E, 0x4802, WORD_LEN, 0 },// x_start
	{0x0990, 0x0010, WORD_LEN, 0 },//	   = 16
	{0x098E, 0x4804, WORD_LEN, 0 },// y_end
	{0x0990, 0x062D, WORD_LEN, 0 },//	   = 1581
	{0x098E, 0x4806, WORD_LEN, 0 },// x_end
	{0x0990, 0x082D, WORD_LEN, 0 },//	   = 2093
	{0x098E, 0x4808, WORD_LEN, 0 },//Base Frame Lines (A)
	{0x0990, 0x0359, WORD_LEN, 0 },//	   = 857
	{0x098E, 0x480A, WORD_LEN, 0 },//Line Length (A)
	{0x0990, 0x0A9B, WORD_LEN, 0 },	//      = 2715
	{0x098E, 0x480C, WORD_LEN, 0 },//Fine Correction (A)
	{0x0990, 0x0399, WORD_LEN, 0 },//	   = 921
	{0x098E, 0x480E, WORD_LEN, 0 },//Row Speed (A)
	{0x0990, 0x0111, WORD_LEN, 0 },//	   = 273
	{0x098E, 0x4810, WORD_LEN, 0 },//Read Mode (A)
	{0x0990, 0x046C, WORD_LEN, 0 },//046C //	  = 1132 //mirror  mode
	{0x098E, 0x4812, WORD_LEN, 0 },//Fine IT Min (A)
	{0x0990, 0x0510, WORD_LEN, 0 },//	   = 1296
	{0x098E, 0x4814, WORD_LEN, 0 },//Fine IT Max Margin (A)
	{0x0990, 0x01BA, WORD_LEN, 0 },//	   = 442
	{0x098E, 0x482D, WORD_LEN, 0 },//Row Start (B)
	{0x0990, 0x0018, WORD_LEN, 0 },//	   = 24
	{0x098E, 0x482F, WORD_LEN, 0 },//Column Start (B)
	{0x0990, 0x0018, WORD_LEN, 0 },//	   = 24
	{0x098E, 0x4831, WORD_LEN, 0 },//Row End (B)
	{0x0990, 0x0627, WORD_LEN, 0 },//	   = 1575
	{0x098E, 0x4833, WORD_LEN, 0 },//Column End (B)
	{0x0990, 0x0827, WORD_LEN, 0 },//	   = 2087
	{0x098E, 0x4835, WORD_LEN, 0 },//Base Frame Lines (B)
	{0x0990, 0x065D, WORD_LEN, 0 },//	   = 1629
	{0x098E, 0x4837, WORD_LEN, 0 },//Line Length (B)
	{0x0990, 0x16DF, WORD_LEN, 0 },	//      = 5855
	{0x098E, 0x4839, WORD_LEN, 0 },//Fine Correction (B)
	{0x0990, 0x019F, WORD_LEN, 0 },//	   = 415
	{0x098E, 0x483B, WORD_LEN, 0 },//Row Speed (B)
	{0x0990, 0x0111, WORD_LEN, 0 },//	   = 273
	{0x098E, 0x483D, WORD_LEN, 0 },//Read Mode (B)
	{0x0990, 0x0024, WORD_LEN, 0 },//	0024//		= 36 //mirror mode
	{0x098E, 0x483F, WORD_LEN, 0 },//Fine IT Min (B)
	{0x0990, 0x0266, WORD_LEN, 0 },//	   = 614
	{0x098E, 0x4841, WORD_LEN, 0 },//Fine IT Max Margin (B)
	{0x0990, 0x010A, WORD_LEN, 0 },//	   = 266
	{0x098E, 0xB81A, WORD_LEN, 0 },//fd_zone_height
	{0x0990, 0x0006, WORD_LEN, 0 },   //06
	{0x098E, 0x481A, WORD_LEN, 0 },//fd_period_50hz
	{0x0990, 0x0101, WORD_LEN, 0 },  //257
	{0x098E, 0x481C, WORD_LEN, 0 },//fd_pediod_60hz 
	{0x0990, 0x00D6, WORD_LEN, 0 },  //214
	{0x098E, 0xC81E, WORD_LEN, 0 },//fd_search_f1_50hz
	{0x0990, 0x0022, WORD_LEN, 0 },  //34
	{0x098E, 0xC81F, WORD_LEN, 0 },//fd_search_f2_50hz
	{0x0990, 0x0024, WORD_LEN, 0 },   //36
	{0x098E, 0xC820, WORD_LEN, 0 },//fd_search_f1_60hz
	{0x0990, 0x0029, WORD_LEN, 0 },   //41
	{0x098E, 0xC821, WORD_LEN, 0 },//fd_search_f2_60hz
	{0x0990, 0x002B, WORD_LEN, 0 },  //43
	{0x098E, 0x4847, WORD_LEN, 0 },//fd_period_50Hz (B)
	{0x0990, 0x0077, WORD_LEN, 0 },  //119
	{0x098E, 0x4849, WORD_LEN, 0 },//fd_pediod_60hz (B)
	{0x0990, 0x0063, WORD_LEN, 0 },  //99
	{0x098E, 0xC84B, WORD_LEN, 0 },//fd_search_f1_50hz (B)
	{0x0990, 0x000F, WORD_LEN, 0 },  //15
	{0x098E, 0xC84C, WORD_LEN, 0 },//fd_search_f2_50hz (B)
	{0x0990, 0x0011, WORD_LEN, 0 },  //17
	{0x098E, 0xC84D, WORD_LEN, 0 },//fd_search_f1_60hz (B)
	{0x0990, 0x0012, WORD_LEN, 0 },   //18
	{0x098E, 0xC84E, WORD_LEN, 0 },//fd_search_f2_60hz (B)
	{0x0990, 0x0014, WORD_LEN, 0 },  //20
				  
	{0x098E, 0x6800, WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x0280, WORD_LEN, 0 },
	{0x098E, 0x6802, WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x01E0, WORD_LEN, 0 },
				  
	{0x098E, 0x6804, WORD_LEN, 0 },//FOV Width (A)
	{0x0990, 0x0800, WORD_LEN, 0 },//	   = 2048
	{0x098E, 0x6806, WORD_LEN, 0 },//FOV Height (A)
	{0x0990, 0x0600, WORD_LEN, 0 },//	   = 1536
	{0x098E, 0xE892, WORD_LEN, 0 },//JPEG Mode (A)
	{0x0990, 0x0000, WORD_LEN, 0 },//	   = 0
	{0x098E, 0x6C00, WORD_LEN, 0 },//Output Width (B)
	{0x0990, 0x0800, WORD_LEN, 0 },//	   = 2048
	{0x098E, 0x6C02, WORD_LEN, 0 },//Output Height (B)
	{0x0990, 0x0600, WORD_LEN, 0 },//	   = 1536
	{0x098E, 0x6C04, WORD_LEN, 0 },//FOV Width (B)
	{0x0990, 0x0800, WORD_LEN, 0 },//	   = 2048
	{0x098E, 0x6C06, WORD_LEN, 0 },//FOV Height (B)
	{0x0990, 0x0600, WORD_LEN, 0 },//	   = 1536
	{0x098E, 0xEC92, WORD_LEN, 0 },//JPEG Mode (B)
	{0x0990, 0x0000, WORD_LEN, 0 },//	   = 0



#else
	//800x600 18.65fps 8.45 24M 64M
	
	{0x0018, 0x4129, WORD_LEN, 0 },// TANDBY_CONTROL_AND_STATUS
	{SEQUENCE_WAIT_MS,100, WORD_LEN, 0},
	{0x0018, 0x4029, WORD_LEN, 0 },// STANDBY_CONTROL_AND_STATUS
	{SEQUENCE_WAIT_MS,100, WORD_LEN, 0},
	{0x0010, 0x0220, WORD_LEN, 0 },  	// PLL_CONTROL
	{0x0012, 0x0070, WORD_LEN, 0 },// PLL_P_DIVIDERS
	{0x002A, 0x75CB, WORD_LEN, 0 },  	// PLL_CONTROL
	{0x0018, 0x402E, WORD_LEN, 0 },  	// PLL_DIVIDERS//31E
		{SEQUENCE_WAIT_MS,10, WORD_LEN, 0},

	{0x0022, 0x0140, WORD_LEN, 0 },  	// PLL_P4_P5_P6_DIVIDERS//7EFF
	{0x001E, 0x0777, WORD_LEN, 0 },  	// RESET_AND_MISC_CONTROL
	{0x3B84, 0x0066, WORD_LEN, 0 },  	// PLL_CONTROL

	{0x0018, 0x4028, WORD_LEN, 0 },  	// PLL_DIVIDERS//31E

//	{0x0990, 0x0000, WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x4800, WORD_LEN, 0 },//Row Start (A)
	{0x0990, 0x0010, WORD_LEN, 0 },//	   = 16
	{0x098E, 0x4802, WORD_LEN, 0 },//Column Start (A)
	{0x0990, 0x0010, WORD_LEN, 0 },//	   = 16
	{0x098E, 0x4804, WORD_LEN, 0 },//Row End (A)
	{0x0990, 0x062D, WORD_LEN, 0 },//	   = 1581
	{0x098E, 0x4806, WORD_LEN, 0 },//Column End (A)
	{0x0990, 0x082D, WORD_LEN, 0 },//	   = 2093
	{0x098E, 0x4808, WORD_LEN, 0 },//Base Frame Lines (A)
	{0x0990, 0x0359, WORD_LEN, 0 },//	   = 857
	{0x098E, 0x480A, WORD_LEN, 0 },//Line Length (A)
	{0x0990, 0x0A78, WORD_LEN, 0 },	//      = 6344
	{0x098E, 0x480C, WORD_LEN, 0 },//Fine Correction (A)
	{0x0990, 0x0399, WORD_LEN, 0 },//	   = 921
	{0x098E, 0x480E, WORD_LEN, 0 },//Row Speed (A)
	{0x0990, 0x0111, WORD_LEN, 0 },//	   = 273
	{0x098E, 0x4810, WORD_LEN, 0 },//Read Mode (A)
	{0x0990, 0x046C, WORD_LEN, 0 },//046C //	  = 1132 //mirror  mode
	{0x098E, 0x4812, WORD_LEN, 0 },//Fine IT Min (A)
	{0x0990, 0x0510, WORD_LEN, 0 },//	   = 1296
	{0x098E, 0x4814, WORD_LEN, 0 },//Fine IT Max Margin (A)
	{0x0990, 0x01BA, WORD_LEN, 0 },//	   = 442
	{0x098E, 0x482D, WORD_LEN, 0 },//Row Start (B)
	{0x0990, 0x0018, WORD_LEN, 0 },//	   = 24
	{0x098E, 0x482F, WORD_LEN, 0 },//Column Start (B)
	{0x0990, 0x0018, WORD_LEN, 0 },//	   = 24
	{0x098E, 0x4831, WORD_LEN, 0 },//Row End (B)
	{0x0990, 0x0627, WORD_LEN, 0 },//	   = 1575
	{0x098E, 0x4833, WORD_LEN, 0 },//Column End (B)
	{0x0990, 0x0827, WORD_LEN, 0 },//	   = 2087
	{0x098E, 0x4835, WORD_LEN, 0 },//Base Frame Lines (B)
	{0x0990, 0x065D, WORD_LEN, 0 },//	   = 1629
	{0x098E, 0x4837, WORD_LEN, 0 },//Line Length (B)
	{0x0990, 0x0C1B, WORD_LEN, 0 },	//      = 6586
	{0x098E, 0x4839, WORD_LEN, 0 },//Fine Correction (B)
	{0x0990, 0x019F, WORD_LEN, 0 },//	   = 415
	{0x098E, 0x483B, WORD_LEN, 0 },//Row Speed (B)
	{0x0990, 0x0111, WORD_LEN, 0 },//	   = 273
	{0x098E, 0x483D, WORD_LEN, 0 },//Read Mode (B)
	{0x0990, 0x0024, WORD_LEN, 0 },//	0024//		= 36 //mirror mode
	{0x098E, 0x483F, WORD_LEN, 0 },//Fine IT Min (B)
	{0x0990, 0x0266, WORD_LEN, 0 },//	   = 614
	{0x098E, 0x4841, WORD_LEN, 0 },//Fine IT Max Margin (B)
	{0x0990, 0x010A, WORD_LEN, 0 },//	   = 266
	{0x098E, 0xB81A, WORD_LEN, 0 },//fd_zone_height
{0x0990, 0x0004, WORD_LEN, 0 },   //05
	{0x098E, 0x481A, WORD_LEN, 0 },
{0x0990, 0x009F, WORD_LEN, 0 },  //D2
	{0x098E, 0x481C, WORD_LEN, 0 },
{0x0990, 0x0085, WORD_LEN, 0 },  //AF
	{0x098E, 0xC81E, WORD_LEN, 0 },
{0x0990, 0x0020, WORD_LEN, 0 },  //22
	{0x098E, 0xC81F, WORD_LEN, 0 },
{0x0990, 0x0022, WORD_LEN, 0 },   //24
	{0x098E, 0xC820, WORD_LEN, 0 },
{0x0990, 0x0026, WORD_LEN, 0 },   //29
	{0x098E, 0xC821, WORD_LEN, 0 },
{0x0990, 0x0028, WORD_LEN, 0 },  //2B
	{0x098E, 0x4847, WORD_LEN, 0 },
{0x0990, 0x008A, WORD_LEN, 0 },  //69
	{0x098E, 0x4849, WORD_LEN, 0 },
{0x0990, 0x0073, WORD_LEN, 0 },  //58
	{0x098E, 0xC84B, WORD_LEN, 0 },//fd_search_f1_50hz (B)
{0x0990, 0x001B, WORD_LEN, 0 },  //10
	{0x098E, 0xC84C, WORD_LEN, 0 },//fd_search_f2_50hz (B)
{0x0990, 0x001D, WORD_LEN, 0 },  //12
	{0x098E, 0xC84D, WORD_LEN, 0 },//fd_search_f1_60hz (B)
{0x0990, 0x0021, WORD_LEN, 0 },   //14
	{0x098E, 0xC84E, WORD_LEN, 0 },//fd_search_f2_60hz (B)
{0x0990, 0x0023, WORD_LEN, 0 },  //16
				  
	{0x098E, 0x6800, WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x0320, WORD_LEN, 0 },
	{0x098E, 0x6802, WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x0258, WORD_LEN, 0 },
				  
	{0x098E, 0x6804, WORD_LEN, 0 },//FOV Width (A)
	{0x0990, 0x0400, WORD_LEN, 0 },//	   = 1024
	{0x098E, 0x6806, WORD_LEN, 0 },//FOV Height (A)
	{0x0990, 0x0300, WORD_LEN, 0 },//	   = 768
	{0x098E, 0xE892, WORD_LEN, 0 },//JPEG Mode (A)
	{0x0990, 0x0000, WORD_LEN, 0 },//	   = 0
	{0x098E, 0x6C00, WORD_LEN, 0 },//Output Width (B)
	{0x0990, 0x0800, WORD_LEN, 0 },//	   = 2048
	{0x098E, 0x6C02, WORD_LEN, 0 },//Output Height (B)
	{0x0990, 0x0600, WORD_LEN, 0 },//	   = 1536
	{0x098E, 0x6C04, WORD_LEN, 0 },//FOV Width (B)
	{0x0990, 0x0800, WORD_LEN, 0 },//	   = 2048
	{0x098E, 0x6C06, WORD_LEN, 0 },//FOV Height (B)
	{0x0990, 0x0600, WORD_LEN, 0 },//	   = 1536
	{0x098E, 0xEC92, WORD_LEN, 0 },//JPEG Mode (B)
	{0x0990, 0x0000, WORD_LEN, 0 },//	   = 0
#endif

#if 0 
	//800x600 18.65fps 8.45 24M 64M
	{0x098E, 0x6CA6, WORD_LEN, 0 },// MCU_ADDRESS [PRI_B_CONFIG_JPEG_OB_TX_CONTROL_VAR]
	{0x0990, 0x082D, WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0xECA5, WORD_LEN, 0 },// MCU_ADDRESS [PRI_B_CONFIG_JPEG_OB_SPOOF_CONTROL_VAR]
	{0x0990, 0x0000, WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x6C94, WORD_LEN, 0 },// MCU_ADDRESS [PRI_B_CONFIG_JPEG_CONFIG]
	{0x0990, 0x0C34, WORD_LEN, 0 },// MCU_DATA_0
	{0x3172, 0x0033, WORD_LEN, 0 },	// ANALOG_CONTROL2
	{0x3C86, 0x00E1, WORD_LEN, 0 },// OB_PCLK1_CONFIG
	{0x3C20, 0x0000, WORD_LEN, 0 },// TX_SS_CONTROL
	
	 //FD_set
	{0x098E, 0xA005 , WORD_LEN, 0 },// MCU_ADDRESS [FD_FDPERIOD_SELECT]
	{0x0990, 0x0001 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x680F , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_FD_ALGO_ENTER]
	{0x0990, 0x0003 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0xA006 , WORD_LEN, 0 },// MCU_ADDRESS [FD_SMOOTH_COUNTER]
	{0x0990, 0x0008 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0xA007 , WORD_LEN, 0 },// MCU_ADDRESS [FD_STAT_MIN]
	{0x0990, 0x0003 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0xA008 , WORD_LEN, 0 },// MCU_ADDRESS [FD_STAT_MAX]
	{0x0990, 0x0005 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0xA00A , WORD_LEN, 0 },// MCU_ADDRESS [FD_MIN_AMPLITUDE]
	{0x0990, 0x0000 , WORD_LEN, 0 },// MCU_DATA_0
	//[CCM2]
	//[Register Log 07/20/11 16:23:36]
	{0x098E, 0x4873 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_L_0]
	{0x0990, 0x012B , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4875 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_L_1]
	{0x0990, 0xFF8A , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4877 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_L_2]
	{0x0990, 0x004A , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4879 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_L_3]
	{0x0990, 0xFFC7 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x487B , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_L_4]
	{0x0990, 0x014E , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x487D , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_L_5]
	{0x0990, 0xFFE9 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x487F , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_L_6]
	{0x0990, 0xFFEB , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4881 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_L_7]
	{0x0990, 0xFF58 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4883 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_L_8]
	{0x0990, 0x01BB , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4885 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_L_9]
	{0x0990, 0x001B , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4887 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_L_10]
	{0x0990, 0x0050 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4889 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_RL_0]
	{0x0990, 0x00BF , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x488B , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_RL_1]
	{0x0990, 0xFFC3 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x488D , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_RL_2]
	{0x0990, 0xFF7A , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x488F , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_RL_3]
	{0x0990, 0x001C , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4891 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_RL_4]
	{0x0990, 0xFFCB , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4893 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_RL_5]
	{0x0990, 0x0017 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4895 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_RL_6]
	{0x0990, 0x000E , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4897 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_RL_7]
	{0x0990, 0x0039 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x4899 , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_RL_8]
	{0x0990, 0xFFB8 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x489B , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_RL_9]
	{0x0990, 0x0016 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x489D , WORD_LEN, 0 },//MCU_ADDRESS [CAM1_AWB_CCM_RL_10]
	{0x0990, 0xFFE3 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x6857 , WORD_LEN, 0 },//MCU_ADDRESS [PRI_A_CONFIG_AWB_X_START]
	{0x0990, 0x0000 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x6859 , WORD_LEN, 0 },//MCU_ADDRESS [PRI_A_CONFIG_AWB_Y_START]
	{0x0990, 0x0000 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x685B , WORD_LEN, 0 },//MCU_ADDRESS [PRI_A_CONFIG_AWB_X_END]
	{0x0990, 0x03FF , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E, 0x685D , WORD_LEN, 0 },//MCU_ADDRESS [PRI_A_CONFIG_AWB_Y_END]
	{0x0990, 0x02FF , WORD_LEN, 0 },//MCU_DATA_0
	
	 //AWB
	{0x098E, 0x48B8 , WORD_LEN, 0 }, 	// MCU_ADDRESS [CAM1_AWB_X_SHIFT]
  {0x0990, 0x0021 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48BA , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_Y_SHIFT]
  {0x0990, 0x0015 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48BC , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_RECIP_XSCALE]
  {0x0990, 0x0080 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48BE , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_RECIP_YSCALE]
  {0x0990, 0x00AB , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48C0 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_ROT_CENTER_X]
  {0x0990, 0x03FC , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48C2 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_ROT_CENTER_Y]
  {0x0990, 0x03E1 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0xC8C4 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_ROT_SIN]
  {0x0990, 0x0036 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0xC8C5 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_ROT_COS]
  {0x0990, 0x0023 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48C6 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_0]
  {0x0990, 0x0000 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48C8 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_1]
  {0x0990, 0x0011 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48CA , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_2]
  {0x0990, 0x1110 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48CC , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_3]
  {0x0990, 0x0000 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48CE , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_4]
  {0x0990, 0x0000 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48D0 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_5]
  {0x0990, 0x0011 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48D2 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_6]
  {0x0990, 0x1111 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48D4 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_7]
  {0x0990, 0x1000 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48D6 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_8]
  {0x0990, 0x0000 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48D8 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_9]
  {0x0990, 0x1111 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48DA , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_10]
  {0x0990, 0x2222 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48DC , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_11]
  {0x0990, 0x1100 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48DE , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_12]
  {0x0990, 0x0011 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48E0 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_13]
  {0x0990, 0x2222 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48E2 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_14]
  {0x0990, 0x2222 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48E4 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_15]
  {0x0990, 0x2100 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48E6 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_16]
  {0x0990, 0x0113 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48E8 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_17]
  {0x0990, 0x4543 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48EA , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_18]
  {0x0990, 0x2112 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48EC , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_19]
  {0x0990, 0x2110 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48EE , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_20]
  {0x0990, 0x0123 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48F0 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_21]
  {0x0990, 0x5543 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48F2 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_22]
  {0x0990, 0x2212 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48F4 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_23]
  {0x0990, 0x2210 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48F6 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_24]
  {0x0990, 0x0112 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48F8 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_25]
  {0x0990, 0x3333 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48FA , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_26]
  {0x0990, 0x2111 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48FC , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_27]
  {0x0990, 0x2211 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x48FE , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_28]
  {0x0990, 0x0011 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x4900 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_29]
  {0x0990, 0x1111 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x4902 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_30]
  {0x0990, 0x1111 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0x4904 , WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_31]
  {0x0990, 0x1110 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0xAC3B , WORD_LEN, 0}, 	// MCU_ADDRESS [AWB_R_RATIO_PRE_AWB]
  {0x0990, 0x0055 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0xAC3C , WORD_LEN, 0}, 	// MCU_ADDRESS [AWB_B_RATIO_PRE_AWB]
  {0x0990, 0x0025 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0xAC37 , WORD_LEN, 0}, 	// MCU_ADDRESS [AWB_R_SCENE_RATIO_LOWER]
  {0x0990, 0x0036 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0xAC38 , WORD_LEN, 0}, 	// MCU_ADDRESS [AWB_R_SCENE_RATIO_UPPER]
  {0x0990, 0x005E , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0xAC39 , WORD_LEN, 0}, 	// MCU_ADDRESS [AWB_B_SCENE_RATIO_LOWER]
  {0x0990, 0x0026 , WORD_LEN, 0}, 	// MCU_DATA_0
  {0x098E, 0xAC3A , WORD_LEN, 0}, 	// MCU_ADDRESS [AWB_B_SCENE_RATIO_UPPER]
  {0x0990, 0x004B , WORD_LEN, 0}, 	// MCU_DATA_0
	
	//[Char_settings]
	{0x3ED6,  0x0F00 , WORD_LEN, 0 },// RESERVED
	{0x3EF2,  0xD965 , WORD_LEN, 0 },// RESERVED
	{0x3FD2,  0xD965 , WORD_LEN, 0 },// RESERVED
	{0x3EF8,  0x7F7F , WORD_LEN, 0 },// RESERVED
	{0x3ED8,  0x7F1D , WORD_LEN, 0 },// RESERVED
	{0x3172,  0x0033 , WORD_LEN, 0 },// RESERVED
	{0x3EEA,  0x0200 , WORD_LEN, 0 },// RESERVED
	{0x3EE2,  0x0050 , WORD_LEN, 0 },// RESERVED
	{0x316A,  0x8200 , WORD_LEN, 0 },// RESERVED
	{0x316C,  0x8200 , WORD_LEN, 0 },// RESERVED
	{0x3EFC,  0xA8E8 , WORD_LEN, 0 },// RESERVED
	{0x3EFE,  0x130D , WORD_LEN, 0 },// RESERVED
	// Additional Optimized Settings
	{0x3180,  0xB3FF , WORD_LEN, 0 },// RESERVED
	{0x30B2,  0xC000 , WORD_LEN, 0 },// RESERVED
	{0x30BC,  0x0384 , WORD_LEN, 0 },// RESERVED
	{0x30C0,  0x1220 , WORD_LEN, 0 },// RESERVED
	
	 // Low_Power_Mode
	{0x3170, 0x000A , WORD_LEN, 0 },//Dynamic pwr setting
	{0x3174, 0x8060 , WORD_LEN, 0 },//Dynamic pwr setting
	{0x3ECC, 0x22B0 , WORD_LEN, 0 },//Dynamic pwr setting
	{0x098E, 0x482B , WORD_LEN, 0 },//LP Mode (A)
	{0x0990, 0x22B0 , WORD_LEN, 0 },//
	{0x098E, 0x4858 , WORD_LEN, 0 },//LP Mode (B)
	{0x0990, 0x22B0 , WORD_LEN, 0 },// 
	{0x317A, 0x000A , WORD_LEN, 0 },// 
	{0x098E, 0x4822 , WORD_LEN, 0 },// 
	{0x0990, 0x000A , WORD_LEN, 0 },// 
	{0x098E, 0x4824 , WORD_LEN, 0 },// 
	{0x0990, 0x000A , WORD_LEN, 0 },// 
	{0x098E, 0x484F , WORD_LEN, 0 },// 
	{0x0990, 0x000A , WORD_LEN, 0 },// 
	{0x098E, 0x4851 , WORD_LEN, 0 },// 
	{0x0990, 0x000A , WORD_LEN, 0 },// 
	
	
	//AE
	{0x098E, 0x6820 , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_AE_TRACK_TARGET_FDZONE]
	{0x0990, 0x0007 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x6822 , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_AE_TRACK_TARGET_AGAIN]
	{0x0990, 0x0064 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x6824 , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_AE_TRACK_TARGET_DGAIN]
	{0x0990, 0x0080 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0xE826 , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_AE_TRACK_BASE_TARGET]
	{0x0990, 0x0045 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x6829 , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_AE_TRACK_AE_MIN_VIRT_DGAIN]
	{0x0990, 0x0080 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x682B , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_AE_TRACK_AE_MAX_VIRT_DGAIN]
	{0x0990, 0x0080 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x682D , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_AE_TRACK_AE_MIN_VIRT_AGAIN]
	{0x0990, 0x0038 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x486F , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_CTL_MAX_ANALOG_GAIN]
	{0x0990, 0x0120 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x4871 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_CTL_MIN_ANALOG_GAIN]
	{0x0990, 0x0038 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x682F , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_AE_TRACK_AE_MAX_VIRT_AGAIN]
	{0x0990, 0x0120 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x6815 , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_FD_MAX_FDZONE_50HZ]
	{0x0990, 0x000A , WORD_LEN, 0 },// MCU_DATA_0 0x000A->privew 10fps 0x0014->5fps
	{0x098E, 0x6817 , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_FD_MAX_FDZONE_60HZ]
	{0x0990, 0x000C , WORD_LEN, 0 },// MCU_DATA_0 0x000C->privew 10fps 0x0018->5fps
	
	//low_light
	{0x098E,  0x4918 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_START_GAIN_METRIC]
	{0x0990,  0x0039 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x491A , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_STOP_GAIN_METRIC]
	{0x0990,  0x0100 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x6872 , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_LL_START_BRIGHTNESS]
	{0x0990,  0x0005 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x6874 , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_LL_STOP_BRIGHTNESS]
	{0x0990,  0x008C , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4956 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_DC_START_GAIN_METRIC]
	{0x0990,  0x0040 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4958 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_DC_STOP_GAIN_METRIC]
	{0x0990,  0x0100 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x495A , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_DC_START]
	{0x0990,  0x0000 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x495C , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_DC_STOP]
	{0x0990,  0x0000 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x495E , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_AGG_START_GAIN_METRIC]
	{0x0990,  0x0040 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4960 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_AGG_STOP_GAIN_METRIC]
	{0x0990,  0x0100 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC962 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_AGG_START]
	{0x0990,  0x0000 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC963 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_AGG_STOP]
	{0x0990,  0x0003 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4964 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_START_GAIN_METRIC]
	{0x0990,  0x0040 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4966 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_STOP_GAIN_METRIC]
	{0x0990,  0x0100 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4968 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_T3START]
	{0x0990,  0x0001 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x496A , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_T3STOP]
	{0x0990,  0x0001 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x496C , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_T4START]
	{0x0990,  0x0014 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x496E , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_T4STOP]
	{0x0990,  0x000C , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC970 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_TO_START]
	{0x0990,  0x0004 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC971 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_TO_STOP]
	{0x0990,  0x000F , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4972 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_DARK_START_GAIN_METRIC]
	{0x0990,  0x0040 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4974 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_DARK_STOP_GAIN_METRIC]
	{0x0990,  0x0100 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4976 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_DARK_T3START]
	{0x0990,  0x0001 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4978 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_DARK_T3STOP]
	{0x0990,  0x0001 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x497A , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_DARK_T4START]
	{0x0990,  0x00C8 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x497C , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_DARK_T4STOP]
	{0x0990,  0x003C , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC97E , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_DARK_TO_START]
	{0x0990,  0x0004 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC97F , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_CDC_DARK_TO_STOP]
	{0x0990,  0x000F , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x491C , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_GRB_START_GAIN_METRIC]
	{0x0990,  0x0040 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x491E , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_GRB_STOP_GAIN_METRIC]
	{0x0990,  0x0100 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC920 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_GRB_SLOPE_START]
	{0x0990,  0x000B , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC921 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_GRB_SLOPE_STOP]
	{0x0990,  0x002C , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC922 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_GRB_OFFSET_START]
	{0x0990,  0x0007 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC923 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_GRB_OFFSET_STOP]
	{0x0990,  0x001D , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4926 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_START_ANALOG_GAIN]
	{0x0990,  0x0039 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4928 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_END_ANALOG_GAIN]
	{0x0990,  0x00A0 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x492A , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_RAMP_START]
	{0x0990,  0x0082 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x492C , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_RAMP_STOP]
	{0x0990,  0x0040 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x492E , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_SLOPE_START]
	{0x0990,  0x0015 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4930 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_SLOPE_STOP]
	{0x0990,  0x0015 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4932 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_LOW_THRESH1START]
	{0x0990,  0x0002 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4934 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_LOW_THRESH1STOP]
	{0x0990,  0x0004 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4936 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_LOW_THRESH2START]
	{0x0990,  0x0008 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4938 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_LOW_THRESH2STOP]
	{0x0990,  0x0009 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x493A , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_LOW_THRESH3START]
	{0x0990,  0x000C , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x493C , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_LOW_THRESH3STOP]
	{0x0990,  0x000D , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x493E , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_MAX_THRESH_START]
	{0x0990,  0x0015 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4940 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_MAX_THRESH_STOP]
	{0x0990,  0x0013 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC944 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_FLATNESS_START]
	{0x0990,  0x0023 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC945 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_FLATNESS_STOP]
	{0x0990,  0x007F , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC946 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_TRANSITION_START]
	{0x0990,  0x0007 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC947 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_TRANSITION_STOP]
	{0x0990,  0x0001 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC948 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_SOBEL_FLAT_START]
	{0x0990,  0x0002 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC949 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_SOBEL_FLAT_STOP]
	{0x0990,  0x0002 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC94A , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_SOBEL_SHARP_START]
	{0x0990,  0x00FF , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC94B , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_SFFB_SOBEL_SHARP_STOP]
	{0x0990,  0x00FF , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC906 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_DM_EDGE_TH_START]
	{0x0990,  0x0006 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC907 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_DM_EDGE_TH_STOP]
	{0x0990,  0x0028 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC02 , WORD_LEN, 0 },// MCU_ADDRESS [LL_MODE]
	{0x0990,  0x0005 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC908 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_AP_KNEE_START]
	{0x0990,  0x0006 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC909 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_AP_KNEE_STOP]
	{0x0990,  0x0028 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC90A , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_AP_MANTISSA_START]
	{0x0990,  0x0007 , WORD_LEN, 0 },// MCU_DATA_0
	{0x326C,  0x0F0A , WORD_LEN, 0 },// APERTURE_PARAMETERS_2D
	{0x098E,  0xC94C , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_DELTA_GAIN]
	{0x0990,  0x0003 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC94E , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_DELTA_THRESHOLD_START]
	{0x0990,  0x003C , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xC94F , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_DELTA_THRESHOLD_STOP]
	{0x0990,  0x0064 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0xE876 , WORD_LEN, 0 },//MCU_ADDRESS [PRI_A_CONFIG_LL_start_SATURATION]
	{0x0990, 0x00E0 , WORD_LEN, 0 },//MCU_DATA_0
	{0x098E,  0xE877 , WORD_LEN, 0 },// MCU_ADDRESS [PRI_A_CONFIG_LL_END_SATURATION]
	{0x0990,  0x0050 , WORD_LEN, 0 },// MCU_DATA_0
	 //gamma
	{0x098E,  0x3C42 , WORD_LEN, 0 },// MCU_ADDRESS [LL_START_GAMMA_FTB]
	{0x0990,  0x0000 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x3C44 , WORD_LEN, 0 },// MCU_ADDRESS [LL_STOP_GAMMA_FTB]
	{0x0990,  0x0000 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4912 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_START_GAMMA_BM]
	{0x0990,  0x0000 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4914 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_MID_GAMMA_BM]
	{0x0990,  0x0001 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x4916 , WORD_LEN, 0 },// MCU_ADDRESS [CAM1_LL_STOP_GAMMA_BM]
	{0x0990,  0x0037 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC09 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_0]
	{0x0990,  0x0000 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC0A , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_1]
	{0x0990,  0x0011 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC0B , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_2]
	{0x0990,  0x0023 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC0C , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_3]
	{0x0990,  0x003F , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC0D , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_4]
	{0x0990,  0x0067 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC0E , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_5]
	{0x0990,  0x0085 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC0F , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_6]
	{0x0990,  0x009B , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC10 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_7]
	{0x0990,  0x00AD , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC11 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_8]
	{0x0990,  0x00BB , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC12 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_9]
	{0x0990,  0x00C7 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC13 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_10]
	{0x0990,  0x00D1 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC14 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_11]
	{0x0990,  0x00DA , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC15 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_12]
	{0x0990,  0x00E1 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC16 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_13]
	{0x0990,  0x00E8 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC17 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_14]
	{0x0990,  0x00EE , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC18 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_15]
	{0x0990,  0x00F3 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC19 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_16]
	{0x0990,  0x00F7 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC1A , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_17]
	{0x0990,  0x00FB , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC1B , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_CONTRAST_CURVE_18]
	{0x0990,  0x00FF , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC1C , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_0]
	{0x0990,  0x0000 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC1D , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_1]
	{0x0990,  0x0011 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC1E , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_2]
	{0x0990,  0x0023 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC1F , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_3]
	{0x0990,  0x003F , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC20 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_4]
	{0x0990,  0x0067 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC21 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_5]
	{0x0990,  0x0085 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC22 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_6]
	{0x0990,  0x009B , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC23 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_7]
	{0x0990,  0x00AD , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC24 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_8]
	{0x0990,  0x00BB , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC25 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_9]
	{0x0990,  0x00C7 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC26 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_10]
	{0x0990,  0x00D1 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC27 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_11]
	{0x0990,  0x00DA , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC28 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_12]
	{0x0990,  0x00E1 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC29 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_13]
	{0x0990,  0x00E8 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC2A , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_14]
	{0x0990,  0x00EE , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC2B , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_15]
	{0x0990,  0x00F3 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC2C , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_16]
	{0x0990,  0x00F7 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC2D , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_17]
	{0x0990,  0x00FB , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC2E , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NEUTRAL_CURVE_18]
	{0x0990,  0x00FF , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC2F , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_0]
	{0x0990,  0x0000 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC30 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_1]
	{0x0990,  0x0017 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC31 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_2]
	{0x0990,  0x0020 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC32 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_3]
	{0x0990,  0x0032 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC33 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_4]
	{0x0990,  0x005A , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC34 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_5]
	{0x0990,  0x0078 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC35 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_6]
	{0x0990,  0x0089 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC36 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_7]
	{0x0990,  0x0098 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC37 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_8]
	{0x0990,  0x00A6 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC38 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_9]
	{0x0990,  0x00B4 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC39 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_10]
	{0x0990,  0x00C3 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC3A , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_11]
	{0x0990,  0x00CB , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC3B , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_12]
	{0x0990,  0x00D0 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC3C , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_13]
	{0x0990,  0x00D4 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC3D , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_14]
	{0x0990,  0x00DC , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC3E , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_15]
	{0x0990,  0x00E4 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC3F , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_16]
	{0x0990,  0x00EA , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC40 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_17]
	{0x0990,  0x00F5 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0xBC41 , WORD_LEN, 0 },// MCU_ADDRESS [LL_GAMMA_NRCURVE_18]
	{0x0990,  0x00FF , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x3C42 , WORD_LEN, 0 },// MCU_ADDRESS [LL_START_GAMMA_FTB]
	{0x0990,  0x0032 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x3C44 , WORD_LEN, 0 },// MCU_ADDRESS [LL_STOP_GAMMA_FTB]
	{0x0990,  0x0000 , WORD_LEN, 0 },// MCU_DATA_0
	
	//A CCM
	
	{0x098E,  0xAC02 , WORD_LEN, 0 },// MCU_ADDRESS [AWB_MODE]
	{0x0990,  0x0006 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E,  0x2800 , WORD_LEN, 0 },// MCU_ADDRESS [AE_TRACK_STATUS]
	{0x0990,  0x001C , WORD_LEN, 0 },// MCU_DATA_0
//	{0x098E,  0x8400 , WORD_LEN, 0 },// MCU_ADDRESS
//	{0x0990,  0x0006 , WORD_LEN, 0 },// MCU_DATA_0
	
//	{SEQUENCE_WAIT_MS, 0x0200 ,  WORD_LEN, 0 },
	
	
	//[Patch_5_2]
	{0x0982, 0x0000 , WORD_LEN, 0 },// ACCESS_CTL_STAT
	{0x098A, 0x0A80 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x3C3C , WORD_LEN, 0 },
	{0x0992, 0xCE05 , WORD_LEN, 0 },
	{0x0994, 0x1F1F , WORD_LEN, 0 },
	{0x0996, 0x0204 , WORD_LEN, 0 },
	{0x0998, 0x0CCC , WORD_LEN, 0 },
	{0x099A, 0x33D4 , WORD_LEN, 0 },
	{0x099C, 0x30ED , WORD_LEN, 0 },
	{0x099E, 0x00FC , WORD_LEN, 0 },
	{0x098A, 0x0A90 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x0590 , WORD_LEN, 0 },
	{0x0992, 0xBDA8 , WORD_LEN, 0 },
	{0x0994, 0x93CE , WORD_LEN, 0 },
	{0x0996, 0x051F , WORD_LEN, 0 },
	{0x0998, 0x1F02 , WORD_LEN, 0 },
	{0x099A, 0x0110 , WORD_LEN, 0 },
	{0x099C, 0xCC33 , WORD_LEN, 0 },
	{0x099E, 0xD830 , WORD_LEN, 0 },
	{0x098A, 0x0AA0 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0xED02 , WORD_LEN, 0 },
	{0x0992, 0xCC05 , WORD_LEN, 0 },
	{0x0994, 0xB8ED , WORD_LEN, 0 },
	{0x0996, 0x00C6 , WORD_LEN, 0 },
	{0x0998, 0x06BD , WORD_LEN, 0 },
	{0x099A, 0xA8B1 , WORD_LEN, 0 },
	{0x099C, 0xCE05 , WORD_LEN, 0 },
	{0x099E, 0x1F1F , WORD_LEN, 0 },
	{0x098A, 0x0AB0 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x0208 , WORD_LEN, 0 },
	{0x0992, 0x0CCC , WORD_LEN, 0 },
	{0x0994, 0x33D6 , WORD_LEN, 0 },
	{0x0996, 0x30ED , WORD_LEN, 0 },
	{0x0998, 0x00FC , WORD_LEN, 0 },
	{0x099A, 0x0592 , WORD_LEN, 0 },
	{0x099C, 0xBDA8 , WORD_LEN, 0 },
	{0x099E, 0x93CC , WORD_LEN, 0 },
	{0x098A, 0x0AC0 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x33F4 , WORD_LEN, 0 }, 
	{0x0992, 0x30ED , WORD_LEN, 0 },
	{0x0994, 0x02CC , WORD_LEN, 0 },
	{0x0996, 0xFFE9 , WORD_LEN, 0 },
	{0x0998, 0xED00 , WORD_LEN, 0 },
	{0x099A, 0xFC05 , WORD_LEN, 0 },
	{0x099C, 0x94C4 , WORD_LEN, 0 },
	{0x099E, 0x164F , WORD_LEN, 0 },
	{0x098A, 0x0AD0 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0xBDA9 , WORD_LEN, 0 },
	{0x0992, 0x0ACE , WORD_LEN, 0 },
	{0x0994, 0x051F , WORD_LEN, 0 },
	{0x0996, 0x1F02 , WORD_LEN, 0 },
	{0x0998, 0x020A , WORD_LEN, 0 },
	{0x099A, 0xCC32 , WORD_LEN, 0 },
	{0x099C, 0x1030 , WORD_LEN, 0 },
	{0x099E, 0xED00 , WORD_LEN, 0 },
	{0x098A, 0x0AE0 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x4FBD , WORD_LEN, 0 },
	{0x0992, 0xA8E4 , WORD_LEN, 0 },
	{0x0994, 0x3838 , WORD_LEN, 0 },
	{0x0996, 0x393C , WORD_LEN, 0 },
	{0x0998, 0x3CFC , WORD_LEN, 0 },
	{0x099A, 0x0322 , WORD_LEN, 0 },
	{0x099C, 0xB303 , WORD_LEN, 0 },
	{0x099E, 0x2030 , WORD_LEN, 0 },
	{0x098A, 0x0AF0 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0xED02 , WORD_LEN, 0 },
	{0x0992, 0xCE03 , WORD_LEN, 0 },
	{0x0994, 0x141F , WORD_LEN, 0 },
	{0x0996, 0x0408 , WORD_LEN, 0 },
	{0x0998, 0x3ECE , WORD_LEN, 0 },
	{0x099A, 0x0314 , WORD_LEN, 0 },
	{0x099C, 0x1F0B , WORD_LEN, 0 },
	{0x099E, 0x0134 , WORD_LEN, 0 },
	{0x098A, 0x0B00 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x30EC , WORD_LEN, 0 },
	{0x0992, 0x0227 , WORD_LEN, 0 },
	{0x0994, 0x2F83 , WORD_LEN, 0 },
	{0x0996, 0x0000 , WORD_LEN, 0 },
	{0x0998, 0x2C18 , WORD_LEN, 0 },
	{0x099A, 0xF603 , WORD_LEN, 0 },
	{0x099C, 0x244F , WORD_LEN, 0 },
	{0x099E, 0xED00 , WORD_LEN, 0 },
	{0x098A, 0x0B10 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0xFC03 , WORD_LEN, 0 },
	{0x0992, 0x20A3 , WORD_LEN, 0 },
	{0x0994, 0x00B3 , WORD_LEN, 0 },
	{0x0996, 0x0322 , WORD_LEN, 0 },
	{0x0998, 0x241A , WORD_LEN, 0 },
	{0x099A, 0xFC03 , WORD_LEN, 0 },
	{0x099C, 0x22FD , WORD_LEN, 0 },
	{0x099E, 0x0320 , WORD_LEN, 0 },
	{0x098A, 0x0B20 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x2012 , WORD_LEN, 0 },
	{0x0992, 0xF603 , WORD_LEN, 0 },
	{0x0994, 0x244F , WORD_LEN, 0 },
	{0x0996, 0xF303 , WORD_LEN, 0 },
	{0x0998, 0x20B3 , WORD_LEN, 0 },
	{0x099A, 0x0322 , WORD_LEN, 0 },
	{0x099C, 0x2306 , WORD_LEN, 0 },
	{0x099E, 0xFC03 , WORD_LEN, 0 },
	{0x098A, 0x0B30 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x22FD , WORD_LEN, 0 },
	{0x0992, 0x0320 , WORD_LEN, 0 },
	{0x0994, 0xBD7D , WORD_LEN, 0 },
	{0x0996, 0x9038 , WORD_LEN, 0 },
	{0x0998, 0x3839 , WORD_LEN, 0 },
	{0x099A, 0x3C3C , WORD_LEN, 0 },
	{0x099C, 0xFC07 , WORD_LEN, 0 },
	{0x099E, 0x4327 , WORD_LEN, 0 },
	{0x098A, 0x0B40 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x5FDE , WORD_LEN, 0 },
	{0x0992, 0x431F , WORD_LEN, 0 },
	{0x0994, 0xB410 , WORD_LEN, 0 },
	{0x0996, 0x563C , WORD_LEN, 0 },
	{0x0998, 0xFC07 , WORD_LEN, 0 },
	{0x099A, 0x4130 , WORD_LEN, 0 },
	{0x099C, 0xED00 , WORD_LEN, 0 },
	{0x099E, 0x3CCC , WORD_LEN, 0 },
	{0x098A, 0x0B50 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x0008 , WORD_LEN, 0 },
	{0x0992, 0x30ED , WORD_LEN, 0 },
	{0x0994, 0x00FC , WORD_LEN, 0 },
	{0x0996, 0x0743 , WORD_LEN, 0 },
	{0x0998, 0xBDAA , WORD_LEN, 0 },
	{0x099A, 0x7C38 , WORD_LEN, 0 },
	{0x099C, 0x38BD , WORD_LEN, 0 },
	{0x099E, 0xE9E4 , WORD_LEN, 0 },
	{0x098A, 0x0B60 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x30ED , WORD_LEN, 0 },
	{0x0992, 0x02CC , WORD_LEN, 0 },
	{0x0994, 0x0064 , WORD_LEN, 0 },
	{0x0996, 0xED00 , WORD_LEN, 0 },
	{0x0998, 0xCC01 , WORD_LEN, 0 },
	{0x099A, 0x00BD , WORD_LEN, 0 },
	{0x099C, 0xAA7C , WORD_LEN, 0 },
	{0x099E, 0xFD03 , WORD_LEN, 0 },
	{0x098A, 0x0B70 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x103C , WORD_LEN, 0 },
	{0x0992, 0xFC07 , WORD_LEN, 0 },
	{0x0994, 0x4530 , WORD_LEN, 0 },
	{0x0996, 0xED00 , WORD_LEN, 0 },
	{0x0998, 0x3CCC , WORD_LEN, 0 },
	{0x099A, 0x0008 , WORD_LEN, 0 },
	{0x099C, 0x30ED , WORD_LEN, 0 },
	{0x099E, 0x00FC , WORD_LEN, 0 },
	{0x098A, 0x0B80 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x0743 , WORD_LEN, 0 },
	{0x0992, 0xBDAA , WORD_LEN, 0 },
	{0x0994, 0x7C38 , WORD_LEN, 0 },
	{0x0996, 0x38BD , WORD_LEN, 0 },
	{0x0998, 0xE9E4 , WORD_LEN, 0 },
	{0x099A, 0x30ED , WORD_LEN, 0 },
	{0x099C, 0x02CC , WORD_LEN, 0 },
	{0x099E, 0x0064 , WORD_LEN, 0 },
	{0x098A, 0x0B90 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0xED00 , WORD_LEN, 0 },
	{0x0992, 0xCC01 , WORD_LEN, 0 },
	{0x0994, 0x00BD , WORD_LEN, 0 },
	{0x0996, 0xAA7C , WORD_LEN, 0 },
	{0x0998, 0xFD03 , WORD_LEN, 0 },
	{0x099A, 0x1220 , WORD_LEN, 0 },
	{0x099C, 0x03BD , WORD_LEN, 0 },
	{0x099E, 0x7993 , WORD_LEN, 0 },
	{0x098A, 0x0BA0 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x3838 , WORD_LEN, 0 },
	{0x0992, 0x390F , WORD_LEN, 0 },
	{0x0994, 0xF601 , WORD_LEN, 0 },
	{0x0996, 0x05C1 , WORD_LEN, 0 },
	{0x0998, 0x0326 , WORD_LEN, 0 },
	{0x099A, 0x14F6 , WORD_LEN, 0 },
	{0x099C, 0x0106 , WORD_LEN, 0 },
	{0x099E, 0xC106 , WORD_LEN, 0 },
	{0x098A, 0x0BB0 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x260D , WORD_LEN, 0 },
	{0x0992, 0xF630 , WORD_LEN, 0 },
	{0x0994, 0x4DC4 , WORD_LEN, 0 },
	{0x0996, 0xF0CA , WORD_LEN, 0 },
	{0x0998, 0x08F7 , WORD_LEN, 0 },
	{0x099A, 0x304D , WORD_LEN, 0 },
	{0x099C, 0xBD0B , WORD_LEN, 0 },
	{0x099E, 0xC10E , WORD_LEN, 0 },
	{0x098A, 0x0BC0 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x39F6 , WORD_LEN, 0 },
	{0x0992, 0x304D , WORD_LEN, 0 },
	{0x0994, 0xC4F0 , WORD_LEN, 0 },
	{0x0996, 0xCA09 , WORD_LEN, 0 },
	{0x0998, 0xF730 , WORD_LEN, 0 },
	{0x099A, 0x4DDE , WORD_LEN, 0 },
	{0x099C, 0xF218 , WORD_LEN, 0 },
	{0x099E, 0xCE0A , WORD_LEN, 0 },
	{0x098A, 0x0BD0 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x00CC , WORD_LEN, 0 },
	{0x0992, 0x001D , WORD_LEN, 0 },
	{0x0994, 0xBDB5 , WORD_LEN, 0 },
	{0x0996, 0x31DE , WORD_LEN, 0 },
	{0x0998, 0xA818 , WORD_LEN, 0 },
	{0x099A, 0xCE0A , WORD_LEN, 0 },
	{0x099C, 0x1ECC , WORD_LEN, 0 },
	{0x099E, 0x001D , WORD_LEN, 0 },
	{0x098A, 0x0BE0 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0xBDB5 , WORD_LEN, 0 },
	{0x0992, 0x31DE , WORD_LEN, 0 },
	{0x0994, 0xA618 , WORD_LEN, 0 },
	{0x0996, 0xCE0A , WORD_LEN, 0 },
	{0x0998, 0x3CCC , WORD_LEN, 0 },
	{0x099A, 0x0013 , WORD_LEN, 0 },
	{0x099C, 0xBDB5 , WORD_LEN, 0 },
	{0x099E, 0x31CC , WORD_LEN, 0 },
	{0x098A, 0x0BF0 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x0A80 , WORD_LEN, 0 },
	{0x0992, 0xFD0A , WORD_LEN, 0 },
	{0x0994, 0x0ECC , WORD_LEN, 0 },
	{0x0996, 0x0AE7 , WORD_LEN, 0 },
	{0x0998, 0xFD0A , WORD_LEN, 0 },
	{0x099A, 0x30CC , WORD_LEN, 0 },
	{0x099C, 0x0B3A , WORD_LEN, 0 },
	{0x099E, 0xFD0A , WORD_LEN, 0 },
	{0x098A, 0x0C00 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x4CCC , WORD_LEN, 0 },
	{0x0992, 0x0A00 , WORD_LEN, 0 },
	{0x0994, 0xDDF2 , WORD_LEN, 0 },
	{0x0996, 0xCC0A , WORD_LEN, 0 },
	{0x0998, 0x1EDD , WORD_LEN, 0 },
	{0x099A, 0xA8CC , WORD_LEN, 0 },
	{0x099C, 0x0A3C , WORD_LEN, 0 },
	{0x099E, 0xDDA6 , WORD_LEN, 0 },
	{0x098A, 0x0C10 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0xC601 , WORD_LEN, 0 },
	{0x0992, 0xF701 , WORD_LEN, 0 },
	{0x0994, 0x0CF7 , WORD_LEN, 0 },
	{0x0996, 0x010D , WORD_LEN, 0 },
	{0x098A, 0x8C18 , WORD_LEN, 0 },// PHYSICAL_ADDR_ACCESS
	{0x0990, 0x0039 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x0012 , WORD_LEN, 0 },// MCU_ADDRESS [MON_ADDR]
	{0x0990, 0x0BA3 , WORD_LEN, 0 },// MCU_DATA_0
	{0x098E, 0x0003 , WORD_LEN, 0 },// MCU_ADDRESS [MON_ALGO]
	{0x0990, 0x0004 , WORD_LEN, 0 },// MCU_DATA_0


//[Lens Correction 100% 11/01/11 10:11:31]
#if 1
{0x3210, 0x01B0, WORD_LEN, 0 },//PGA_ENABLE  //{0x0008,BIT 0
{0x3640, 0x0190 , WORD_LEN, 0 },//P_G1_P0Q0
{0x3642, 0x286E , WORD_LEN, 0 },//P_G1_P0Q1
{0x3644, 0x6171 , WORD_LEN, 0 },//P_G1_P0Q2
{0x3646, 0x852F , WORD_LEN, 0 },//P_G1_P0Q3
{0x3648, 0xE84E , WORD_LEN, 0 },//P_G1_P0Q4
{0x364A, 0x0290 , WORD_LEN, 0 },//P_R_P0Q0
{0x364C, 0xBAEE , WORD_LEN, 0 },//P_R_P0Q1
{0x364E, 0x5F51 , WORD_LEN, 0 },//P_R_P0Q2
{0x3650, 0x2DAF , WORD_LEN, 0 },//P_R_P0Q3
{0x3652, 0xFA6F , WORD_LEN, 0 },//P_R_P0Q4
{0x3654, 0x0330 , WORD_LEN, 0 },//P_B_P0Q0
{0x3656, 0x56AE , WORD_LEN, 0 },//P_B_P0Q1
{0x3658, 0x0D11 , WORD_LEN, 0 },//P_B_P0Q2
{0x365A, 0xB46F , WORD_LEN, 0 },//P_B_P0Q3
{0x365C, 0x69EF , WORD_LEN, 0 },//P_B_P0Q4
{0x365E, 0x0810 , WORD_LEN, 0 },//P_G2_P0Q0
{0x3660, 0xF9CE , WORD_LEN, 0 },//P_G2_P0Q1
{0x3662, 0x7B71 , WORD_LEN, 0 },//P_G2_P0Q2
{0x3664, 0x974D , WORD_LEN, 0 },//P_G2_P0Q3
{0x3666, 0xBDB0 , WORD_LEN, 0 },//P_G2_P0Q4
{0x3680, 0xA42D , WORD_LEN, 0 },//P_G1_P1Q0
{0x3682, 0xF8EE , WORD_LEN, 0 },//P_G1_P1Q1
{0x3684, 0xE5EF , WORD_LEN, 0 },//P_G1_P1Q2
{0x3686, 0x372F , WORD_LEN, 0 },//P_G1_P1Q3
{0x3688, 0x6411 , WORD_LEN, 0 },//P_G1_P1Q4
{0x368A, 0xB08D , WORD_LEN, 0 },//P_R_P1Q0
{0x368C, 0x3A8E , WORD_LEN, 0 },//P_R_P1Q1
{0x368E, 0xE94D , WORD_LEN, 0 },//P_R_P1Q2
{0x3690, 0xCFF0 , WORD_LEN, 0 },//P_R_P1Q3
{0x3692, 0x25CE , WORD_LEN, 0 },//P_R_P1Q4
{0x3694, 0x170D , WORD_LEN, 0 },//P_B_P1Q0
{0x3696, 0x2BEF , WORD_LEN, 0 },//P_B_P1Q1
{0x3698, 0x5E90 , WORD_LEN, 0 },//P_B_P1Q2
{0x369A, 0x99D0 , WORD_LEN, 0 },//P_B_P1Q3
{0x369C, 0xA731 , WORD_LEN, 0 },//P_B_P1Q4
{0x369E, 0x4DCD , WORD_LEN, 0 },//P_G2_P1Q0
{0x36A0, 0xD76F , WORD_LEN, 0 },//P_G2_P1Q1
{0x36A2, 0x5130 , WORD_LEN, 0 },//P_G2_P1Q2
{0x36A4, 0x08EF , WORD_LEN, 0 },//P_G2_P1Q3
{0x36A6, 0xE630 , WORD_LEN, 0 },//P_G2_P1Q4
{0x36C0, 0x6731 , WORD_LEN, 0 },//P_G1_P2Q0
{0x36C2, 0x246F , WORD_LEN, 0 },//P_G1_P2Q1
{0x36C4, 0x2B32 , WORD_LEN, 0 },//P_G1_P2Q2
{0x36C6, 0x726F , WORD_LEN, 0 },//P_G1_P2Q3
{0x36C8, 0xCC13 , WORD_LEN, 0 },//P_G1_P2Q4
{0x36CA, 0x1972 , WORD_LEN, 0 },//P_R_P2Q0
{0x36CC, 0xC5B0 , WORD_LEN, 0 },//P_R_P2Q1
{0x36CE, 0x4BD2 , WORD_LEN, 0 },//P_R_P2Q2
{0x36D0, 0x97F1 , WORD_LEN, 0 },//P_R_P2Q3
{0x36D2, 0x9034 , WORD_LEN, 0 },//P_R_P2Q4
{0x36D4, 0x43B1 , WORD_LEN, 0 },//P_B_P2Q0
{0x36D6, 0x11F0 , WORD_LEN, 0 },//P_B_P2Q1
{0x36D8, 0x72F2 , WORD_LEN, 0 },//P_B_P2Q2
{0x36DA, 0x1010 , WORD_LEN, 0 },//P_B_P2Q3
{0x36DC, 0xCA13 , WORD_LEN, 0 },//P_B_P2Q4
{0x36DE, 0x6111 , WORD_LEN, 0 },//P_G2_P2Q0
{0x36E0, 0xA0F0 , WORD_LEN, 0 },//P_G2_P2Q1
{0x36E2, 0x0AB2 , WORD_LEN, 0 },//P_G2_P2Q2
{0x36E4, 0xAA91 , WORD_LEN, 0 },//P_G2_P2Q3
{0x36E6, 0x89D2 , WORD_LEN, 0 },//P_G2_P2Q4
{0x3700, 0x960E , WORD_LEN, 0 },//P_G1_P3Q0
{0x3702, 0x662F , WORD_LEN, 0 },//P_G1_P3Q1
{0x3704, 0x66B0 , WORD_LEN, 0 },//P_G1_P3Q2
{0x3706, 0x1C2F , WORD_LEN, 0 },//P_G1_P3Q3
{0x3708, 0x0370 , WORD_LEN, 0 },//P_G1_P3Q4
{0x370A, 0x008E , WORD_LEN, 0 },//P_R_P3Q0
{0x370C, 0x1FEB , WORD_LEN, 0 },//P_R_P3Q1
{0x370E, 0xB5F2 , WORD_LEN, 0 },//P_R_P3Q2
{0x3710, 0x2C72 , WORD_LEN, 0 },//P_R_P3Q3
{0x3712, 0x2CF4 , WORD_LEN, 0 },//P_R_P3Q4
{0x3714, 0x9D50 , WORD_LEN, 0 },//P_B_P3Q0
{0x3716, 0x8CD1 , WORD_LEN, 0 },//P_B_P3Q1
{0x3718, 0xA30F , WORD_LEN, 0 },//P_B_P3Q2
{0x371A, 0x20F3 , WORD_LEN, 0 },//P_B_P3Q3
{0x371C, 0x4C91 , WORD_LEN, 0 },//P_B_P3Q4
{0x371E, 0x22AD , WORD_LEN, 0 },//P_G2_P3Q0
{0x3720, 0x1BAF , WORD_LEN, 0 },//P_G2_P3Q1
{0x3722, 0xF850 , WORD_LEN, 0 },//P_G2_P3Q2
{0x3724, 0x24D1 , WORD_LEN, 0 },//P_G2_P3Q3
{0x3726, 0x7EB2 , WORD_LEN, 0 },//P_G2_P3Q4
{0x3740, 0x8891 , WORD_LEN, 0 },//P_G1_P4Q0
{0x3742, 0x08F0 , WORD_LEN, 0 },//P_G1_P4Q1
{0x3744, 0xF0F3 , WORD_LEN, 0 },//P_G1_P4Q2
{0x3746, 0x8DB3 , WORD_LEN, 0 },//P_G1_P4Q3
{0x3748, 0xC054 , WORD_LEN, 0 },//P_G1_P4Q4
{0x374A, 0xBCB1 , WORD_LEN, 0 },//P_R_P4Q0
{0x374C, 0x0A92 , WORD_LEN, 0 },//P_R_P4Q1
{0x374E, 0x8A75 , WORD_LEN, 0 },//P_R_P4Q2
{0x3750, 0x01B3 , WORD_LEN, 0 },//P_R_P4Q3
{0x3752, 0x2B16 , WORD_LEN, 0 },//P_R_P4Q4
{0x3754, 0x93B2 , WORD_LEN, 0 },//P_B_P4Q0
{0x3756, 0xA092 , WORD_LEN, 0 },//P_B_P4Q1
{0x3758, 0x8D54 , WORD_LEN, 0 },//P_B_P4Q2
{0x375A, 0x33D2 , WORD_LEN, 0 },//P_B_P4Q3
{0x375C, 0x1FB4 , WORD_LEN, 0 },//P_B_P4Q4
{0x375E, 0xBD8F , WORD_LEN, 0 },//P_G2_P4Q0
{0x3760, 0x0711 , WORD_LEN, 0 },//P_G2_P4Q1
{0x3762, 0xF853 , WORD_LEN, 0 },//P_G2_P4Q2
{0x3764, 0x3E14 , WORD_LEN, 0 },//P_G2_P4Q3
{0x3766, 0xFCB4 , WORD_LEN, 0 },//P_G2_P4Q4
{0x3782, 0x0360 , WORD_LEN, 0 },//CENTER_ROW
{0x3784, 0x0410 , WORD_LEN, 0 },//CENTER_COLUMN
{0x3210, 0x01B8, WORD_LEN, 0 },//PGA_ENABLE
#else
{0x3210, 0x01B0, WORD_LEN, 0 },// COLOR_PIPELINE_CONTROL
{0x3640, 0x02D0, WORD_LEN, 0 },// P_G1_P0Q0
{0x3642, 0x39CE, WORD_LEN, 0 },// P_G1_P0Q1
{0x3644, 0x4251, WORD_LEN, 0 },// P_G1_P0Q2
{0x3646, 0xE52E, WORD_LEN, 0 },// P_G1_P0Q3
{0x3648, 0x8230, WORD_LEN, 0 },// P_G1_P0Q4
{0x364A, 0x0350, WORD_LEN, 0 },// P_R_P0Q0
{0x364C, 0x936E, WORD_LEN, 0 },// P_R_P0Q1
{0x364E, 0x0291, WORD_LEN, 0 },// P_R_P0Q2
{0x3650, 0x0CAF, WORD_LEN, 0 },// P_R_P0Q3
{0x3652, 0x0AB0, WORD_LEN, 0 },// P_R_P0Q4
{0x3654, 0x0530, WORD_LEN, 0 },// P_B_P0Q0
{0x3656, 0x0B0F, WORD_LEN, 0 },// P_B_P0Q1
{0x3658, 0x0591, WORD_LEN, 0 },// P_B_P0Q2
{0x365A, 0xE92F, WORD_LEN, 0 },// P_B_P0Q3
{0x365C, 0x416D, WORD_LEN, 0 },// P_B_P0Q4
{0x365E, 0x0870, WORD_LEN, 0 },// P_G2_P0Q0
{0x3660, 0xE1AE, WORD_LEN, 0 },// P_G2_P0Q1
{0x3662, 0x5611, WORD_LEN, 0 },// P_G2_P0Q2
{0x3664, 0x49AD, WORD_LEN, 0 },// P_G2_P0Q3
{0x3666, 0xD7F0, WORD_LEN, 0 },// P_G2_P0Q4
{0x3680, 0xC7CC, WORD_LEN, 0 },// P_G1_P1Q0
{0x3682, 0xFCCE, WORD_LEN, 0 },// P_G1_P1Q1
{0x3684, 0x9430, WORD_LEN, 0 },// P_G1_P1Q2
{0x3686, 0x3BEF, WORD_LEN, 0 },// P_G1_P1Q3
{0x3688, 0x14D1, WORD_LEN, 0 },// P_G1_P1Q4
{0x368A, 0x828D, WORD_LEN, 0 },// P_R_P1Q0
{0x368C, 0x7D2E, WORD_LEN, 0 },// P_R_P1Q1
{0x368E, 0xAC8E, WORD_LEN, 0 },// P_R_P1Q2
{0x3690, 0x9D50, WORD_LEN, 0 },// P_R_P1Q3
{0x3692, 0x35EE, WORD_LEN, 0 },// P_R_P1Q4
{0x3694, 0x43ED, WORD_LEN, 0 },// P_B_P1Q0
{0x3696, 0x194F, WORD_LEN, 0 },// P_B_P1Q1
{0x3698, 0x3410, WORD_LEN, 0 },// P_B_P1Q2
{0x369A, 0xAAB0, WORD_LEN, 0 },// P_B_P1Q3
{0x369C, 0x9C12, WORD_LEN, 0 },// P_B_P1Q4
{0x369E, 0x0AEE, WORD_LEN, 0 },// P_G2_P1Q0
{0x36A0, 0xA96F, WORD_LEN, 0 },// P_G2_P1Q1
{0x36A2, 0x72CF, WORD_LEN, 0 },// P_G2_P1Q2
{0x36A4, 0x4690, WORD_LEN, 0 },// P_G2_P1Q3
{0x36A6, 0xC231, WORD_LEN, 0 },// P_G2_P1Q4
{0x36C0, 0x5371, WORD_LEN, 0 },// P_G1_P2Q0
{0x36C2, 0x0EAF, WORD_LEN, 0 },// P_G1_P2Q1
{0x36C4, 0x58B0, WORD_LEN, 0 },// P_G1_P2Q2
{0x36C6, 0x2D91, WORD_LEN, 0 },// P_G1_P2Q3
{0x36C8, 0xBD31, WORD_LEN, 0 },// P_G1_P2Q4
{0x36CA, 0x3651, WORD_LEN, 0 },// P_R_P2Q0
{0x36CC, 0xA6F0, WORD_LEN, 0 },// P_R_P2Q1
{0x36CE, 0x1BB3, WORD_LEN, 0 },// P_R_P2Q2
{0x36D0, 0x0A91, WORD_LEN, 0 },// P_R_P2Q3
{0x36D2, 0xC674, WORD_LEN, 0 },// P_R_P2Q4
{0x36D4, 0x3DD1, WORD_LEN, 0 },// P_B_P2Q0
{0x36D6, 0x0A70, WORD_LEN, 0 },// P_B_P2Q1
{0x36D8, 0x7811, WORD_LEN, 0 },// P_B_P2Q2
{0x36DA, 0x00D2, WORD_LEN, 0 },// P_B_P2Q3
{0x36DC, 0xE290, WORD_LEN, 0 },// P_B_P2Q4
{0x36DE, 0x4DD1, WORD_LEN, 0 },// P_G2_P2Q0
{0x36E0, 0x8B50, WORD_LEN, 0 },// P_G2_P2Q1
{0x36E2, 0x2C4F, WORD_LEN, 0 },// P_G2_P2Q2
{0x36E4, 0x460F, WORD_LEN, 0 },// P_G2_P2Q3
{0x36E6, 0xD7AF, WORD_LEN, 0 },// P_G2_P2Q4
{0x3700, 0xA9CC, WORD_LEN, 0 },// P_G1_P3Q0
{0x3702, 0x36CF, WORD_LEN, 0 },// P_G1_P3Q1
{0x3704, 0xD5AF, WORD_LEN, 0 },// P_G1_P3Q2
{0x3706, 0xF291, WORD_LEN, 0 },// P_G1_P3Q3
{0x3708, 0x64D2, WORD_LEN, 0 },// P_G1_P3Q4
{0x370A, 0x6BEE, WORD_LEN, 0 },// P_R_P3Q0
{0x370C, 0xA6EF, WORD_LEN, 0 },// P_R_P3Q1
{0x370E, 0x8172, WORD_LEN, 0 },// P_R_P3Q2
{0x3710, 0x48B1, WORD_LEN, 0 },// P_R_P3Q3
{0x3712, 0x25F3, WORD_LEN, 0 },// P_R_P3Q4
{0x3714, 0x878C, WORD_LEN, 0 },// P_B_P3Q0
{0x3716, 0xA8AE, WORD_LEN, 0 },// P_B_P3Q1
{0x3718, 0xA1D1, WORD_LEN, 0 },// P_B_P3Q2
{0x371A, 0x4612, WORD_LEN, 0 },// P_B_P3Q3
{0x371C, 0x0C74, WORD_LEN, 0 },// P_B_P3Q4
{0x371E, 0x9CA9, WORD_LEN, 0 },// P_G2_P3Q0
{0x3720, 0x4B70, WORD_LEN, 0 },// P_G2_P3Q1
{0x3722, 0xEE31, WORD_LEN, 0 },// P_G2_P3Q2
{0x3724, 0xCDD2, WORD_LEN, 0 },// P_G2_P3Q3
{0x3726, 0x37D3, WORD_LEN, 0 },// P_G2_P3Q4
{0x3740, 0xF1F1, WORD_LEN, 0 },// P_G1_P4Q0
{0x3742, 0xE24F, WORD_LEN, 0 },// P_G1_P4Q1
{0x3744, 0x7453, WORD_LEN, 0 },// P_G1_P4Q2
{0x3746, 0x41AC, WORD_LEN, 0 },// P_G1_P4Q3
{0x3748, 0x8697, WORD_LEN, 0 },// P_G1_P4Q4
{0x374A, 0xC12F, WORD_LEN, 0 },// P_R_P4Q0
{0x374C, 0x6F71, WORD_LEN, 0 },// P_R_P4Q1
{0x374E, 0xECB3, WORD_LEN, 0 },// P_R_P4Q2
{0x3750, 0x92B3, WORD_LEN, 0 },// P_R_P4Q3
{0x3752, 0x8CF5, WORD_LEN, 0 },// P_R_P4Q4
{0x3754, 0x86B2, WORD_LEN, 0 },// P_B_P4Q0
{0x3756, 0xBB92, WORD_LEN, 0 },// P_B_P4Q1
{0x3758, 0x6A51, WORD_LEN, 0 },// P_B_P4Q2
{0x375A, 0xAC13, WORD_LEN, 0 },// P_B_P4Q3
{0x375C, 0xBDB6, WORD_LEN, 0 },// P_B_P4Q4
{0x375E, 0xD0D1, WORD_LEN, 0 },// P_G2_P4Q0
{0x3760, 0x3811, WORD_LEN, 0 },// P_G2_P4Q1
{0x3762, 0x4DD3, WORD_LEN, 0 },// P_G2_P4Q2
{0x3764, 0x4F33, WORD_LEN, 0 },// P_G2_P4Q3
{0x3766, 0x8157, WORD_LEN, 0 },// P_G2_P4Q4
{0x3782, 0x02D0, WORD_LEN, 0 },// CENTER_ROW
{0x3784, 0x03F0, WORD_LEN, 0 },// CENTER_COLUMN
{0x3210, 0x01B8, WORD_LEN, 0 },// COLOR_PIPELINE_CONTROL

#endif
	// flickr, 50Hz
	{0x098E, 0x2003, WORD_LEN, 0},       // FD_ALGO
	{0x0990, 0x0002, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0xA005, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x0001, WORD_LEN, 0},       // MCU_DATA_0

	// fps, >10fps
	{0x098E, 0x6815, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_50hz 
	{0x0990, 0x0007, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6817, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_60hz 
	{0x0990, 0x0007, WORD_LEN, 0},       // MCU_DATA_0

	{SEQUENCE_WAIT_MS, 10 , WORD_LEN, 0 },
	{0x0018, 0x002A       , WORD_LEN, 0 },// STANDBY_CONTROL_AND_STATUS
#else
// 24M Mclk, 96M Pclk, 640x480 @30fps, 2048x1536 @7.32fps
// Effect parameter, like patch, ae, awb, etc...

{0x3172, 0x0033, WORD_LEN, 0},	// ANALOG_CONTROL2
	
	//TX
{0x3C86, 0x00E1, WORD_LEN, 0},	// OB_PCLK1_CONFIG
{0x3C20, 0x0000, WORD_LEN, 0},	// TX_SS_CONTROL
	
	
	// K46A_REV03_PATCH01_REV1
{0x0982, 0x0000, WORD_LEN, 0},  // ACCESS_CTL_STAT
{0x098A, 0x0A80, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x3C3C, WORD_LEN, 0}, 
{0x0992, 0xCE05, WORD_LEN, 0}, 
{0x0994, 0x1F1F, WORD_LEN, 0}, 
{0x0996, 0x0204, WORD_LEN, 0}, 
{0x0998, 0x0CCC, WORD_LEN, 0}, 
{0x099A, 0x33D4, WORD_LEN, 0}, 
{0x099C, 0x30ED, WORD_LEN, 0}, 
{0x099E, 0x00FC, WORD_LEN, 0}, 
{0x098A, 0x0A90, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x0590, WORD_LEN, 0}, 
{0x0992, 0xBDA8, WORD_LEN, 0}, 
{0x0994, 0x93CE, WORD_LEN, 0}, 
{0x0996, 0x051F, WORD_LEN, 0}, 
{0x0998, 0x1F02, WORD_LEN, 0}, 
{0x099A, 0x0110, WORD_LEN, 0}, 
{0x099C, 0xCC33, WORD_LEN, 0}, 
{0x099E, 0xD830, WORD_LEN, 0}, 
{0x098A, 0x0AA0, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0xED02, WORD_LEN, 0}, 
{0x0992, 0xCC05, WORD_LEN, 0}, 
{0x0994, 0xB8ED, WORD_LEN, 0}, 
{0x0996, 0x00C6, WORD_LEN, 0}, 
{0x0998, 0x06BD, WORD_LEN, 0}, 
{0x099A, 0xA8B1, WORD_LEN, 0}, 
{0x099C, 0xCE05, WORD_LEN, 0}, 
{0x099E, 0x1F1F, WORD_LEN, 0}, 
{0x098A, 0x0AB0, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x0208, WORD_LEN, 0}, 
{0x0992, 0x0CCC, WORD_LEN, 0}, 
{0x0994, 0x33D6, WORD_LEN, 0}, 
{0x0996, 0x30ED, WORD_LEN, 0}, 
{0x0998, 0x00FC, WORD_LEN, 0}, 
{0x099A, 0x0592, WORD_LEN, 0}, 
{0x099C, 0xBDA8, WORD_LEN, 0}, 
{0x099E, 0x93CC, WORD_LEN, 0}, 
{0x098A, 0x0AC0, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x33F4, WORD_LEN, 0}, 
{0x0992, 0x30ED, WORD_LEN, 0}, 
{0x0994, 0x02CC, WORD_LEN, 0}, 
{0x0996, 0xFFE9, WORD_LEN, 0}, 
{0x0998, 0xED00, WORD_LEN, 0}, 
{0x099A, 0xFC05, WORD_LEN, 0}, 
{0x099C, 0x94C4, WORD_LEN, 0}, 
{0x099E, 0x164F, WORD_LEN, 0}, 
{0x098A, 0x0AD0, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0xBDA9, WORD_LEN, 0}, 
{0x0992, 0x0ACE, WORD_LEN, 0}, 
{0x0994, 0x051F, WORD_LEN, 0}, 
{0x0996, 0x1F02, WORD_LEN, 0}, 
{0x0998, 0x020A, WORD_LEN, 0}, 
{0x099A, 0xCC32, WORD_LEN, 0}, 
{0x099C, 0x1030, WORD_LEN, 0}, 
{0x099E, 0xED00, WORD_LEN, 0}, 
{0x098A, 0x0AE0, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x4FBD, WORD_LEN, 0}, 
{0x0992, 0xA8E4, WORD_LEN, 0}, 
{0x0994, 0x3838, WORD_LEN, 0}, 
{0x0996, 0x393C, WORD_LEN, 0}, 
{0x0998, 0x3CFC, WORD_LEN, 0}, 
{0x099A, 0x0322, WORD_LEN, 0}, 
{0x099C, 0xB303, WORD_LEN, 0}, 
{0x099E, 0x2030, WORD_LEN, 0}, 
{0x098A, 0x0AF0, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0xED02, WORD_LEN, 0}, 
{0x0992, 0xCE03, WORD_LEN, 0}, 
{0x0994, 0x141F, WORD_LEN, 0}, 
{0x0996, 0x0408, WORD_LEN, 0}, 
{0x0998, 0x3ECE, WORD_LEN, 0}, 
{0x099A, 0x0314, WORD_LEN, 0}, 
{0x099C, 0x1F0B, WORD_LEN, 0}, 
{0x099E, 0x0134, WORD_LEN, 0}, 
{0x098A, 0x0B00, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x30EC, WORD_LEN, 0}, 
{0x0992, 0x0227, WORD_LEN, 0}, 
{0x0994, 0x2F83, WORD_LEN, 0}, 
{0x0996, 0x0000, WORD_LEN, 0}, 
{0x0998, 0x2C18, WORD_LEN, 0}, 
{0x099A, 0xF603, WORD_LEN, 0}, 
{0x099C, 0x244F, WORD_LEN, 0}, 
{0x099E, 0xED00, WORD_LEN, 0}, 
{0x098A, 0x0B10, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0xFC03, WORD_LEN, 0}, 
{0x0992, 0x20A3, WORD_LEN, 0}, 
{0x0994, 0x00B3, WORD_LEN, 0}, 
{0x0996, 0x0322, WORD_LEN, 0}, 
{0x0998, 0x241A, WORD_LEN, 0}, 
{0x099A, 0xFC03, WORD_LEN, 0}, 
{0x099C, 0x22FD, WORD_LEN, 0}, 
{0x099E, 0x0320, WORD_LEN, 0}, 
{0x098A, 0x0B20, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x2012, WORD_LEN, 0}, 
{0x0992, 0xF603, WORD_LEN, 0}, 
{0x0994, 0x244F, WORD_LEN, 0}, 
{0x0996, 0xF303, WORD_LEN, 0}, 
{0x0998, 0x20B3, WORD_LEN, 0}, 
{0x099A, 0x0322, WORD_LEN, 0}, 
{0x099C, 0x2306, WORD_LEN, 0}, 
{0x099E, 0xFC03, WORD_LEN, 0}, 
{0x098A, 0x0B30, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x22FD, WORD_LEN, 0}, 
{0x0992, 0x0320, WORD_LEN, 0}, 
{0x0994, 0xBD7D, WORD_LEN, 0}, 
{0x0996, 0x9038, WORD_LEN, 0}, 
{0x0998, 0x3839, WORD_LEN, 0}, 
{0x099A, 0x3C3C, WORD_LEN, 0}, 
{0x099C, 0xFC07, WORD_LEN, 0}, 
{0x099E, 0x4327, WORD_LEN, 0}, 
{0x098A, 0x0B40, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x5FDE, WORD_LEN, 0}, 
{0x0992, 0x431F, WORD_LEN, 0}, 
{0x0994, 0xB410, WORD_LEN, 0}, 
{0x0996, 0x563C, WORD_LEN, 0}, 
{0x0998, 0xFC07, WORD_LEN, 0}, 
{0x099A, 0x4130, WORD_LEN, 0}, 
{0x099C, 0xED00, WORD_LEN, 0}, 
{0x099E, 0x3CCC, WORD_LEN, 0}, 
{0x098A, 0x0B50, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x0008, WORD_LEN, 0}, 
{0x0992, 0x30ED, WORD_LEN, 0}, 
{0x0994, 0x00FC, WORD_LEN, 0}, 
{0x0996, 0x0743, WORD_LEN, 0}, 
{0x0998, 0xBDAA, WORD_LEN, 0}, 
{0x099A, 0x7C38, WORD_LEN, 0}, 
{0x099C, 0x38BD, WORD_LEN, 0}, 
{0x099E, 0xE9E4, WORD_LEN, 0}, 
{0x098A, 0x0B60, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x30ED, WORD_LEN, 0}, 
{0x0992, 0x02CC, WORD_LEN, 0}, 
{0x0994, 0x0064, WORD_LEN, 0}, 
{0x0996, 0xED00, WORD_LEN, 0}, 
{0x0998, 0xCC01, WORD_LEN, 0}, 
{0x099A, 0x00BD, WORD_LEN, 0}, 
{0x099C, 0xAA7C, WORD_LEN, 0}, 
{0x099E, 0xFD03, WORD_LEN, 0}, 
{0x098A, 0x0B70, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x103C, WORD_LEN, 0}, 
{0x0992, 0xFC07, WORD_LEN, 0}, 
{0x0994, 0x4530, WORD_LEN, 0}, 
{0x0996, 0xED00, WORD_LEN, 0}, 
{0x0998, 0x3CCC, WORD_LEN, 0}, 
{0x099A, 0x0008, WORD_LEN, 0}, 
{0x099C, 0x30ED, WORD_LEN, 0}, 
{0x099E, 0x00FC, WORD_LEN, 0}, 
{0x098A, 0x0B80, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x0743, WORD_LEN, 0}, 
{0x0992, 0xBDAA, WORD_LEN, 0}, 
{0x0994, 0x7C38, WORD_LEN, 0}, 
{0x0996, 0x38BD, WORD_LEN, 0}, 
{0x0998, 0xE9E4, WORD_LEN, 0}, 
{0x099A, 0x30ED, WORD_LEN, 0}, 
{0x099C, 0x02CC, WORD_LEN, 0}, 
{0x099E, 0x0064, WORD_LEN, 0}, 
{0x098A, 0x0B90, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0xED00, WORD_LEN, 0}, 
{0x0992, 0xCC01, WORD_LEN, 0}, 
{0x0994, 0x00BD, WORD_LEN, 0}, 
{0x0996, 0xAA7C, WORD_LEN, 0}, 
{0x0998, 0xFD03, WORD_LEN, 0}, 
{0x099A, 0x1220, WORD_LEN, 0}, 
{0x099C, 0x03BD, WORD_LEN, 0}, 
{0x099E, 0x7993, WORD_LEN, 0}, 
{0x098A, 0x0BA0, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x3838, WORD_LEN, 0}, 
{0x0992, 0x390F, WORD_LEN, 0}, 
{0x0994, 0xF601, WORD_LEN, 0}, 
{0x0996, 0x05C1, WORD_LEN, 0}, 
{0x0998, 0x0326, WORD_LEN, 0}, 
{0x099A, 0x14F6, WORD_LEN, 0}, 
{0x099C, 0x0106, WORD_LEN, 0}, 
{0x099E, 0xC106, WORD_LEN, 0}, 
{0x098A, 0x0BB0, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x260D, WORD_LEN, 0}, 
{0x0992, 0xF630, WORD_LEN, 0}, 
{0x0994, 0x4DC4, WORD_LEN, 0}, 
{0x0996, 0xF0CA, WORD_LEN, 0}, 
{0x0998, 0x08F7, WORD_LEN, 0}, 
{0x099A, 0x304D, WORD_LEN, 0}, 
{0x099C, 0xBD0B, WORD_LEN, 0}, 
{0x099E, 0xC10E, WORD_LEN, 0}, 
{0x098A, 0x0BC0, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x39F6, WORD_LEN, 0}, 
{0x0992, 0x304D, WORD_LEN, 0}, 
{0x0994, 0xC4F0, WORD_LEN, 0}, 
{0x0996, 0xCA09, WORD_LEN, 0}, 
{0x0998, 0xF730, WORD_LEN, 0}, 
{0x099A, 0x4DDE, WORD_LEN, 0}, 
{0x099C, 0xF218, WORD_LEN, 0}, 
{0x099E, 0xCE0A, WORD_LEN, 0}, 
{0x098A, 0x0BD0, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x00CC, WORD_LEN, 0}, 
{0x0992, 0x001D, WORD_LEN, 0}, 
{0x0994, 0xBDB5, WORD_LEN, 0}, 
{0x0996, 0x31DE, WORD_LEN, 0}, 
{0x0998, 0xA818, WORD_LEN, 0}, 
{0x099A, 0xCE0A, WORD_LEN, 0}, 
{0x099C, 0x1ECC, WORD_LEN, 0}, 
{0x099E, 0x001D, WORD_LEN, 0}, 
{0x098A, 0x0BE0, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0xBDB5, WORD_LEN, 0}, 
{0x0992, 0x31DE, WORD_LEN, 0}, 
{0x0994, 0xA618, WORD_LEN, 0}, 
{0x0996, 0xCE0A, WORD_LEN, 0}, 
{0x0998, 0x3CCC, WORD_LEN, 0}, 
{0x099A, 0x0013, WORD_LEN, 0}, 
{0x099C, 0xBDB5, WORD_LEN, 0}, 
{0x099E, 0x31CC, WORD_LEN, 0}, 
{0x098A, 0x0BF0, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x0A80, WORD_LEN, 0}, 
{0x0992, 0xFD0A, WORD_LEN, 0}, 
{0x0994, 0x0ECC, WORD_LEN, 0}, 
{0x0996, 0x0AE7, WORD_LEN, 0}, 
{0x0998, 0xFD0A, WORD_LEN, 0}, 
{0x099A, 0x30CC, WORD_LEN, 0}, 
{0x099C, 0x0B3A, WORD_LEN, 0}, 
{0x099E, 0xFD0A, WORD_LEN, 0}, 
{0x098A, 0x0C00, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x4CCC, WORD_LEN, 0}, 
{0x0992, 0x0A00, WORD_LEN, 0}, 
{0x0994, 0xDDF2, WORD_LEN, 0}, 
{0x0996, 0xCC0A, WORD_LEN, 0}, 
{0x0998, 0x1EDD, WORD_LEN, 0}, 
{0x099A, 0xA8CC, WORD_LEN, 0}, 
{0x099C, 0x0A3C, WORD_LEN, 0}, 
{0x099E, 0xDDA6, WORD_LEN, 0}, 
{0x098A, 0x0C10, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0xC601, WORD_LEN, 0}, 
{0x0992, 0xF701, WORD_LEN, 0}, 
{0x0994, 0x0CF7, WORD_LEN, 0}, 
{0x0996, 0x010D, WORD_LEN, 0}, 
{0x098A, 0x8C18, WORD_LEN, 0}, 	// PHYSICAL_ADDR_ACCESS
{0x0990, 0x0039, WORD_LEN, 0}, 	// MCU_DATA_0
{0x098E, 0x0012, WORD_LEN, 0}, 	// MCU_ADDRESS [MON_ADDR]
{0x0990, 0x0BA3, WORD_LEN, 0}, 	// MCU_DATA_0
{0x098E, 0x0003, WORD_LEN, 0}, 	// MCU_ADDRESS [MON_ALGO]
{0x0990, 0x0004, WORD_LEN, 0}, 	// MCU_DATA_0
{SEQUENCE_WAIT_MS, 10 , WORD_LEN, 0 },
	//POLL_FIELD=MON_RAM_PATCH_ID,==0,DELAY=10,TIMEOUT=100		   // wait for the 
	
	
//Char_settings
{0x3ED6, 0x0F00, WORD_LEN, 0},	// DAC_LD_10_11
{0x3EF2, 0xD965, WORD_LEN, 0},	// DAC_LP_6_7
{0x3FD2, 0xD965, WORD_LEN, 0},
{0x3EF8, 0x7F7F, WORD_LEN, 0},	// DAC_LD_TXHI
{0x3ED8, 0x7F1D, WORD_LEN, 0},	// DAC_LD_12_13
{0x3172, 0x0033, WORD_LEN, 0},	// ANALOG_CONTROL2
{0x3EEA, 0x0200, WORD_LEN, 0},	// DAC_LD_30_31
{0x3EE2, 0x0050, WORD_LEN, 0},	// DAC_LD_22_23
{0x316A, 0x8200, WORD_LEN, 0},	// DAC_FBIAS
{0x316C, 0x8200, WORD_LEN, 0},	// DAC_TXLO
{0x3EFC, 0xA8E8, WORD_LEN, 0},	// DAC_LD_FBIAS
{0x3EFE, 0x130D, WORD_LEN, 0},	// DAC_LD_TXLO
{0x30BC, 0x0384, WORD_LEN, 0},	// CALIB_GLOBAL
{0x30C0, 0x1220, WORD_LEN, 0},	// CALIB_CONTROL

	//Low_Power_Mode
{0x3170, 0x000A, WORD_LEN, 0},  //Dynamic pwr setting
{0x3174, 0x8031, WORD_LEN, 0},  //Dynamic pwr setting
{0x317A, 0x000A, WORD_LEN, 0},  //Dynamic pwr setting
{0x3ECC, 0x22B0, WORD_LEN, 0},  //Dynamic pwr setting
{0x098E, 0x482B, WORD_LEN, 0},	
{0x0990, 0x22B0, WORD_LEN, 0},	
{0x098E, 0x4858, WORD_LEN, 0},	
{0x0990, 0x22B0, WORD_LEN, 0},	
{0x098E, 0x4822, WORD_LEN, 0},	
{0x0990, 0x000A, WORD_LEN, 0},	
{0x098E, 0x4824, WORD_LEN, 0},	
{0x0990, 0x000A, WORD_LEN, 0},	
{0x098E, 0x484F, WORD_LEN, 0},	
{0x0990, 0x000A, WORD_LEN, 0},	
{0x098E, 0x4851, WORD_LEN, 0},	
{0x0990, 0x000A, WORD_LEN, 0}, 



	//AWB_CCM
{0x098E, 0x4873, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_L_0]
{0x0990, 0x0206, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4875, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_L_1]
{0x0990, 0xFEDA, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4877, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_L_2]
{0x0990, 0x001F, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4879, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_L_3]
{0x0990, 0xFFC7, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x487B, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_L_4]
{0x0990, 0x014E, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x487D, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_L_5]
{0x0990, 0xFFE9, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x487F, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_L_6]
{0x0990, 0xFFAD, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4881, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_L_7]
{0x0990, 0xFF12, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4883, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_L_8]
{0x0990, 0x023F, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4885, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_L_9]
{0x0990, 0x001D, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4887, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_L_10]
{0x0990, 0x005E, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4889, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_RL_0]
{0x0990, 0xFFA2, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x488B, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_RL_1]
{0x0990, 0x00A5, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x488D, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_RL_2]
{0x0990, 0xFFB6, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x488F, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_RL_3]
{0x0990, 0x0002, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4891, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_RL_4]
{0x0990, 0xFFE5, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4893, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_RL_5]
{0x0990, 0x0017, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4895, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_RL_6]
{0x0990, 0x004C, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4897, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_RL_7]
{0x0990, 0x007F, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4899, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_RL_8]
{0x0990, 0xFF34, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x489B, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_RL_9]
{0x0990, 0x0014, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x489D, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_CCM_RL_10]
{0x0990, 0xFFCF, WORD_LEN, 0},	// MCU_DATA_0
	
	
{0x098E, 0x48B8, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_X_SHIFT]
{0x0990, 0x001D, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48BA, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_Y_SHIFT]
{0x0990, 0x001D, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48BC, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_RECIP_XSCALE]
{0x0990, 0x00AB, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48BE, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_RECIP_YSCALE]
{0x0990, 0x0080, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48C0, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_ROT_CENTER_X]
{0x0990, 0x03F8, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48C2, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_ROT_CENTER_Y]
{0x0990, 0x03E2, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC8C4, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_ROT_SIN]
{0x0990, 0x0036, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC8C5, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_ROT_COS]
{0x0990, 0x0023, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48C6, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_0]
{0x0990, 0x0000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48C8, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_1]
{0x0990, 0x0000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48CA, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_2]
{0x0990, 0x0000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48CC, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_3]
{0x0990, 0x0000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48CE, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_4]
{0x0990, 0x0000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48D0, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_5]
{0x0990, 0x0111, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48D2, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_6]
{0x0990, 0x1111, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48D4, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_7]
{0x0990, 0x1000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48D6, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_8]
{0x0990, 0x0000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48D8, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_9]
{0x0990, 0x1111, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48DA, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_10]
{0x0990, 0x1121, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48DC, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_11]
{0x0990, 0x1110, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48DE, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_12]
{0x0990, 0x0011, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48E0, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_13]
{0x0990, 0x1111, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48E2, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_14]
{0x0990, 0x1122, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48E4, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_15]
{0x0990, 0x1110, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48E6, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_16]
{0x0990, 0x1122, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48E8, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_17]
{0x0990, 0x2322, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48EA, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_18]
{0x0990, 0x1111, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48EC, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_19]
{0x0990, 0x2211, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48EE, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_20]
{0x0990, 0x1344, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48F0, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_21]
{0x0990, 0x4432, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48F2, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_22]
{0x0990, 0x1111, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48F4, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_23]
{0x0990, 0x1221, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48F6, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_24]
{0x0990, 0x1244, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48F8, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_25]
{0x0990, 0x4322, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48FA, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_26]
{0x0990, 0x1111, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48FC, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_27]
{0x0990, 0x1121, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x48FE, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_28]
{0x0990, 0x1111, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4900, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_29]
{0x0990, 0x1111, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4902, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_30]
{0x0990, 0x1111, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4904, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_AWB_WEIGHT_TABLE_31]
{0x0990, 0x1111, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xE852, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AWB_K_G_L]
{0x0990, 0x00C5, WORD_LEN, 0}, 	// MCU_DATA_0
{0x098E, 0xE853, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AWB_K_B_L]
{0x0990, 0x00FF, WORD_LEN, 0}, 	// MCU_DATA_0
{0x098E, 0xE854, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AWB_K_R_R]
{0x0990, 0x0080, WORD_LEN, 0}, 	// MCU_DATA_0
{0x098E, 0xE855, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AWB_K_G_R]
{0x0990, 0x0080, WORD_LEN, 0}, 	// MCU_DATA_0
{0x098E, 0xE856, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AWB_K_B_R]
{0x0990, 0x0080, WORD_LEN, 0}, 	// MCU_DATA_0  	
	//Step6-CPIPE_Calibration
	
	//GRB - calibration - 2 sigma
{0x098E, 0xC920, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_GRB_SLOPE_START]
{0x0990, 0x0016, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC921, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_GRB_SLOPE_STOP]
{0x0990, 0x0042, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC922, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_GRB_OFFSET_START]
{0x0990, 0x000F, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC923, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_GRB_OFFSET_STOP]
{0x0990, 0x002C, WORD_LEN, 0},	// MCU_DATA_0
	
	//aperture - calibration1
{0x098E, 0xC908, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_AP_KNEE_START]
{0x0990, 0x000C, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC909, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_AP_KNEE_STOP]
{0x0990, 0x0027, WORD_LEN, 0},	// MCU_DATA_0
	
	//SFFB - calibration - 1.5sigma
{0x098E, 0x492A, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_RAMP_START]
{0x0990, 0x0028, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x492C, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_RAMP_STOP]
{0x0990, 0x0016, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x492E, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_SLOPE_START]
{0x0990, 0x001F, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4930, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_SLOPE_STOP]
{0x0990, 0x000A, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4932, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_LOW_THRESH1START]
{0x0990, 0x0002, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4934, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_LOW_THRESH1STOP]
{0x0990, 0x0006, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4936, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_LOW_THRESH2START]
{0x0990, 0x0003, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4938, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_LOW_THRESH2STOP]
{0x0990, 0x0007, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x493A, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_LOW_THRESH3START]
{0x0990, 0x0004, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x493C, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_LOW_THRESH3STOP]
{0x0990, 0x0008, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x493E, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_MAX_THRESH_START]
{0x0990, 0x0009, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4940, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_MAX_THRESH_STOP]
{0x0990, 0x0015, WORD_LEN, 0},	// MCU_DATA_0
	
	//Demosaic - calibration1
{0x098E, 0xC906, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_DM_EDGE_TH_START]
{0x0990, 0x000C, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC907, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_DM_EDGE_TH_STOP]
{0x0990, 0x0027, WORD_LEN, 0},	// MCU_DATA_0
	
	//Defect - calibration
{0x098E, 0x495A, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_DC_START]
{0x0990, 0x007B, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x495C, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_DC_STOP]
{0x0990, 0x0111, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC970, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_TO_START]
{0x0990, 0x001E, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC971, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_TO_STOP]
{0x0990, 0x0042, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC97E, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_TO_START]
{0x0990, 0x001E, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC97F, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_TO_STOP]
{0x0990, 0x0042, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4968, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_T3START]
{0x0990, 0x0001, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x496A, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_T3STOP]
{0x0990, 0x0001, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4976, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_T3START]
{0x0990, 0x0001, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4978, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_T3STOP]
{0x0990, 0x0001, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x496C, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_T4START]
{0x0990, 0x00C6, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x496E, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_T4STOP]
{0x0990, 0x000c, WORD_LEN, 0},	// 0x01C2 MCU_DATA_0
{0x098E, 0x497A, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_T4START]
{0x0990, 0x00C6, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x497C, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_T4STOP]
{0x0990, 0x01C2, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC962, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_AGG_START]
{0x0990, 0x0000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC963, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_AGG_STOP]
{0x0990, 0x0003, WORD_LEN, 0},	// MCU_DATA_0
	
	//
{0x098E, 0xBC02, WORD_LEN, 0},	// MCU_ADDRESS [LL_MODE]
{0x0990, 0x0005, WORD_LEN, 0},	// 0x000DMCU_DATA_0
{0x326E, 0x0006, WORD_LEN, 0},	// LOW_PASS_YUV_FILTER
	
	//Step7-CPIPE_Preference
	//Lower Maxgain case
{0x326C, 0x170A, WORD_LEN, 0},	// APERTURE_PARAMETERS_2D
{0x3210, 0x00B8, WORD_LEN, 0},	// COLOR_PIPELINE_CONTROL
	
{0x098E, 0x6824, WORD_LEN, 0},	// MCU_ADDRESS [PRI_A_CONFIG_AE_TRACK_TARGET_DGAIN]
{0x0990, 0x0080, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x682B, WORD_LEN, 0},	// MCU_ADDRESS [PRI_A_CONFIG_AE_TRACK_AE_MAX_VIRT_DGAIN]
{0x0990, 0x0080, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x2800, WORD_LEN, 0},	// MCU_ADDRESS [AE_TRACK_STATUS]
{0x0990, 0x001C, WORD_LEN, 0},	// MCU_DATA_0

{0x098E, 0x682F, WORD_LEN, 0},	// MCU_ADDRESS
{0x0990, 0x0100, WORD_LEN, 0},	// MCU_DATA_0// gain

	
{0x098E, 0x492A, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_RAMP_START]
{0x0990, 0x0050, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC944, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_FLATNESS_START]
{0x0990, 0x003C, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC949, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_SOBEL_FLAT_STOP]
{0x0990, 0x0002, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC942, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_SHARPENING_START]
{0x0990, 0x00FF, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC943, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_SFFB_SHARPENING_STOP]
{0x0990, 0x00FF, WORD_LEN, 0},	// MCU_DATA_0
	
{0x098E, 0x4956, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_DC_START_GAIN_METRIC]
{0x0990, 0x0040, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4958, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_DC_STOP_GAIN_METRIC]
{0x0990, 0x01F4, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x495A, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_DC_START]
{0x0990, 0x0000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x495C, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_DC_STOP]
{0x0990, 0x0000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xBC02, WORD_LEN, 0},	// MCU_ADDRESS [LL_MODE]
{0x0990, 0x0005, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x495E, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_AGG_START_GAIN_METRIC]
{0x0990, 0x0040, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4960, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_AGG_STOP_GAIN_METRIC]
{0x0990, 0x01F4, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC962, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_AGG_START]
{0x0990, 0x0000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC963, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_AGG_STOP]
{0x0990, 0x0003, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4964, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_START_GAIN_METRIC]
{0x0990, 0x0040, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4966, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_STOP_GAIN_METRIC]
{0x0990, 0x01F4, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4968, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_T3START]
{0x0990, 0x0001, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x496A, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_T3STOP]
{0x0990, 0x0001, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x496C, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_T4START]
{0x0990, 0x00C8, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x496E, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_T4STOP]
{0x0990, 0x003C, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC970, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_TO_START]
{0x0990, 0x0004, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC971, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_BRIGHT_TO_STOP]
{0x0990, 0x000F, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4972, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_START_GAIN_METRIC]
{0x0990, 0x0040, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4974, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_STOP_GAIN_METRIC]
{0x0990, 0x01F4, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4976, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_T3START]
{0x0990, 0x0001, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4978, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_T3STOP]
{0x0990, 0x0001, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x497A, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_T4START]
{0x0990, 0x00C8, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x497C, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_T4STOP]
{0x0990, 0x003C, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC97E, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_TO_START]
{0x0990, 0x0004, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0xC97F, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_CDC_DARK_TO_STOP]
{0x0990, 0x000F, WORD_LEN, 0},	// MCU_DATA_0
	
{0x098E, 0x3C42, WORD_LEN, 0},	// MCU_ADDRESS [LL_START_GAMMA_FTB]
{0x0990, 0x0032, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x3C44, WORD_LEN, 0},	// MCU_ADDRESS [LL_STOP_GAMMA_FTB]
{0x0990, 0x0000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4912, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_START_GAMMA_BM]
{0x0990, 0x0000, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4914, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_MID_GAMMA_BM]
{0x0990, 0x0001, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x4916, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_LL_STOP_GAMMA_BM]
{0x0990, 0x0037, WORD_LEN, 0},	// MCU_DATA_0
	
	//Saturation
{0x098E, 0xC997, WORD_LEN, 0},	// MCU_ADDRESS [CAM1_SYS_UV_COLOR_BOOST]
{0x0990, 0x0005, WORD_LEN, 0},	// MCU_DATA_0
{0x098E, 0x5C03, WORD_LEN, 0},	// MCU_ADDRESS [SYS_ALGO]
{0x0990, 0x000B, WORD_LEN, 0},	// MCU_DATA_0

	
	//Step8-Features
{0x098E, 0x8002, WORD_LEN, 0},		// MCU_ADDRESS [MON_MODE]
{0x0990, 0x0000, WORD_LEN, 0},		// MCU_DATA_0
	
	//Optimized
	//50Hz
{0x098E, 0x2003, WORD_LEN, 0},		// MCU_ADDRESS [FD_ALGO]
{0x0990, 0x0002, WORD_LEN, 0},		// MCU_DATA_0
{0x098E, 0xA005, WORD_LEN, 0},		// MCU_ADDRESS [FD_FDPERIOD_SELECT]
{0x0990, 0x0001, WORD_LEN, 0},		// MCU_DATA_0
	
{0x098E, 0xE876, WORD_LEN, 0},	
{0x0990, 0x0080, WORD_LEN, 0},	 //0x00F0
{0x098E, 0xE877, WORD_LEN, 0},		
{0x0990, 0x0010, WORD_LEN, 0},		//bao he du

{0x098E, 0xBC06, WORD_LEN, 0},	
{0x0990, 0x0002, WORD_LEN, 0},	
{0x098E, 0xE876, WORD_LEN, 0},        // MCU_ADDRESS [PRI_A_CONFIG_LL_START_SATURATION]
{0x0990, 0x0090, WORD_LEN, 0},        // MCU_DATA_0
{0x098E, 0xE826, WORD_LEN, 0},        // MCU_ADDRESS [AE_BASE_TARGET]
{0x0990, 0x0040, WORD_LEN, 0},        // MCU_DATA_0     0x003D


//[4-Lens for BYD under RK platform]
{ 0x3210, 0x01B0, WORD_LEN, 0}, 	// COLOR_PIPELINE_CONTROL
{ 0x3640, 0x02D0, WORD_LEN, 0}, 	// P_G1_P0Q0
{ 0x3642, 0x39CE, WORD_LEN, 0}, 	// P_G1_P0Q1
{ 0x3644, 0x4251, WORD_LEN, 0}, 	// P_G1_P0Q2
{ 0x3646, 0xE52E, WORD_LEN, 0}, 	// P_G1_P0Q3
{ 0x3648, 0x8230, WORD_LEN, 0}, 	// P_G1_P0Q4
{ 0x364A, 0x0350, WORD_LEN, 0}, 	// P_R_P0Q0
{ 0x364C, 0x936E, WORD_LEN, 0}, 	// P_R_P0Q1
{ 0x364E, 0x0291, WORD_LEN, 0}, 	// P_R_P0Q2
{ 0x3650, 0x0CAF, WORD_LEN, 0}, 	// P_R_P0Q3
{ 0x3652, 0x0AB0, WORD_LEN, 0}, 	// P_R_P0Q4
{ 0x3654, 0x0530, WORD_LEN, 0}, 	// P_B_P0Q0
{ 0x3656, 0x0B0F, WORD_LEN, 0}, 	// P_B_P0Q1
{ 0x3658, 0x0591, WORD_LEN, 0}, 	// P_B_P0Q2
{ 0x365A, 0xE92F, WORD_LEN, 0}, 	// P_B_P0Q3
{ 0x365C, 0x416D, WORD_LEN, 0}, 	// P_B_P0Q4
{ 0x365E, 0x0870, WORD_LEN, 0}, 	// P_G2_P0Q0
{ 0x3660, 0xE1AE, WORD_LEN, 0}, 	// P_G2_P0Q1
{ 0x3662, 0x5611, WORD_LEN, 0}, 	// P_G2_P0Q2
{ 0x3664, 0x49AD, WORD_LEN, 0}, 	// P_G2_P0Q3
{ 0x3666, 0xD7F0, WORD_LEN, 0}, 	// P_G2_P0Q4
{ 0x3680, 0xC7CC, WORD_LEN, 0}, 	// P_G1_P1Q0
{ 0x3682, 0xFCCE, WORD_LEN, 0}, 	// P_G1_P1Q1
{ 0x3684, 0x9430, WORD_LEN, 0}, 	// P_G1_P1Q2
{ 0x3686, 0x3BEF, WORD_LEN, 0}, 	// P_G1_P1Q3
{ 0x3688, 0x14D1, WORD_LEN, 0}, 	// P_G1_P1Q4
{ 0x368A, 0x828D, WORD_LEN, 0}, 	// P_R_P1Q0
{ 0x368C, 0x7D2E, WORD_LEN, 0}, 	// P_R_P1Q1
{ 0x368E, 0xAC8E, WORD_LEN, 0}, 	// P_R_P1Q2
{ 0x3690, 0x9D50, WORD_LEN, 0}, 	// P_R_P1Q3
{ 0x3692, 0x35EE, WORD_LEN, 0}, 	// P_R_P1Q4
{ 0x3694, 0x43ED, WORD_LEN, 0}, 	// P_B_P1Q0
{ 0x3696, 0x194F, WORD_LEN, 0}, 	// P_B_P1Q1
{ 0x3698, 0x3410, WORD_LEN, 0}, 	// P_B_P1Q2
{ 0x369A, 0xAAB0, WORD_LEN, 0}, 	// P_B_P1Q3
{ 0x369C, 0x9C12, WORD_LEN, 0}, 	// P_B_P1Q4
{ 0x369E, 0x0AEE, WORD_LEN, 0}, 	// P_G2_P1Q0
{ 0x36A0, 0xA96F, WORD_LEN, 0}, 	// P_G2_P1Q1
{ 0x36A2, 0x72CF, WORD_LEN, 0}, 	// P_G2_P1Q2
{ 0x36A4, 0x4690, WORD_LEN, 0}, 	// P_G2_P1Q3
{ 0x36A6, 0xC231, WORD_LEN, 0}, 	// P_G2_P1Q4
{ 0x36C0, 0x5371, WORD_LEN, 0}, 	// P_G1_P2Q0
{ 0x36C2, 0x0EAF, WORD_LEN, 0}, 	// P_G1_P2Q1
{ 0x36C4, 0x58B0, WORD_LEN, 0}, 	// P_G1_P2Q2
{ 0x36C6, 0x2D91, WORD_LEN, 0}, 	// P_G1_P2Q3
{ 0x36C8, 0xBD31, WORD_LEN, 0}, 	// P_G1_P2Q4
{ 0x36CA, 0x3651, WORD_LEN, 0}, 	// P_R_P2Q0
{ 0x36CC, 0xA6F0, WORD_LEN, 0}, 	// P_R_P2Q1
{ 0x36CE, 0x1BB3, WORD_LEN, 0}, 	// P_R_P2Q2
{ 0x36D0, 0x0A91, WORD_LEN, 0}, 	// P_R_P2Q3
{ 0x36D2, 0xC674, WORD_LEN, 0}, 	// P_R_P2Q4
{ 0x36D4, 0x3DD1, WORD_LEN, 0}, 	// P_B_P2Q0
{ 0x36D6, 0x0A70, WORD_LEN, 0}, 	// P_B_P2Q1
{ 0x36D8, 0x7811, WORD_LEN, 0}, 	// P_B_P2Q2
{ 0x36DA, 0x00D2, WORD_LEN, 0}, 	// P_B_P2Q3
{ 0x36DC, 0xE290, WORD_LEN, 0}, 	// P_B_P2Q4
{ 0x36DE, 0x4DD1, WORD_LEN, 0}, 	// P_G2_P2Q0
{ 0x36E0, 0x8B50, WORD_LEN, 0}, 	// P_G2_P2Q1
{ 0x36E2, 0x2C4F, WORD_LEN, 0}, 	// P_G2_P2Q2
{ 0x36E4, 0x460F, WORD_LEN, 0}, 	// P_G2_P2Q3
{ 0x36E6, 0xD7AF, WORD_LEN, 0}, 	// P_G2_P2Q4
{ 0x3700, 0xA9CC, WORD_LEN, 0}, 	// P_G1_P3Q0
{ 0x3702, 0x36CF, WORD_LEN, 0}, 	// P_G1_P3Q1
{ 0x3704, 0xD5AF, WORD_LEN, 0}, 	// P_G1_P3Q2
{ 0x3706, 0xF291, WORD_LEN, 0}, 	// P_G1_P3Q3
{ 0x3708, 0x64D2, WORD_LEN, 0}, 	// P_G1_P3Q4
{ 0x370A, 0x6BEE, WORD_LEN, 0}, 	// P_R_P3Q0
{ 0x370C, 0xA6EF, WORD_LEN, 0}, 	// P_R_P3Q1
{ 0x370E, 0x8172, WORD_LEN, 0}, 	// P_R_P3Q2
{ 0x3710, 0x48B1, WORD_LEN, 0}, 	// P_R_P3Q3
{ 0x3712, 0x25F3, WORD_LEN, 0}, 	// P_R_P3Q4
{ 0x3714, 0x878C, WORD_LEN, 0}, 	// P_B_P3Q0
{ 0x3716, 0xA8AE, WORD_LEN, 0}, 	// P_B_P3Q1
{ 0x3718, 0xA1D1, WORD_LEN, 0}, 	// P_B_P3Q2
{ 0x371A, 0x4612, WORD_LEN, 0}, 	// P_B_P3Q3
{ 0x371C, 0x0C74, WORD_LEN, 0}, 	// P_B_P3Q4
{ 0x371E, 0x9CA9, WORD_LEN, 0}, 	// P_G2_P3Q0
{ 0x3720, 0x4B70, WORD_LEN, 0}, 	// P_G2_P3Q1
{ 0x3722, 0xEE31, WORD_LEN, 0}, 	// P_G2_P3Q2
{ 0x3724, 0xCDD2, WORD_LEN, 0}, 	// P_G2_P3Q3
{ 0x3726, 0x37D3, WORD_LEN, 0}, 	// P_G2_P3Q4
{ 0x3740, 0xF1F1, WORD_LEN, 0}, 	// P_G1_P4Q0
{ 0x3742, 0xE24F, WORD_LEN, 0}, 	// P_G1_P4Q1
{ 0x3744, 0x7453, WORD_LEN, 0}, 	// P_G1_P4Q2
{ 0x3746, 0x41AC, WORD_LEN, 0}, 	// P_G1_P4Q3
{ 0x3748, 0x8697, WORD_LEN, 0}, 	// P_G1_P4Q4
{ 0x374A, 0xC12F, WORD_LEN, 0}, 	// P_R_P4Q0
{ 0x374C, 0x6F71, WORD_LEN, 0}, 	// P_R_P4Q1
{ 0x374E, 0xECB3, WORD_LEN, 0}, 	// P_R_P4Q2
{ 0x3750, 0x92B3, WORD_LEN, 0}, 	// P_R_P4Q3
{ 0x3752, 0x8CF5, WORD_LEN, 0}, 	// P_R_P4Q4
{ 0x3754, 0x86B2, WORD_LEN, 0}, 	// P_B_P4Q0
{ 0x3756, 0xBB92, WORD_LEN, 0}, 	// P_B_P4Q1
{ 0x3758, 0x6A51, WORD_LEN, 0}, 	// P_B_P4Q2
{ 0x375A, 0xAC13, WORD_LEN, 0}, 	// P_B_P4Q3
{ 0x375C, 0xBDB6, WORD_LEN, 0}, 	// P_B_P4Q4
{ 0x375E, 0xD0D1, WORD_LEN, 0}, 	// P_G2_P4Q0
{ 0x3760, 0x3811, WORD_LEN, 0}, 	// P_G2_P4Q1
{ 0x3762, 0x4DD3, WORD_LEN, 0}, 	// P_G2_P4Q2
{ 0x3764, 0x4F33, WORD_LEN, 0}, 	// P_G2_P4Q3
{ 0x3766, 0x8157, WORD_LEN, 0}, 	// P_G2_P4Q4
{ 0x3782, 0x02D0, WORD_LEN, 0}, 	// CENTER_ROW
{ 0x3784, 0x03F0, WORD_LEN, 0}, 	// CENTER_COLUMN
{ 0x3210, 0x01B8, WORD_LEN, 0}, 	// COLOR_PIPELINE_CONTROL


// Optimization
{ 0x326C, 0x0A00, WORD_LEN, 0},   // Sharpness


// 180 orientation
//{ 0x098E, 0x4810, WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_CTX_A_READ_MODE]
//{ 0x0990, 0x046F, WORD_LEN, 0}, 	// MCU_DATA_0
//{ 0x098E, 0x483D, WORD_LEN, 0}, 	// MCU_ADDRESS [CAM1_CTX_B_READ_MODE]
//{ 0x0990, 0x0027, WORD_LEN, 0}, 	// MCU_DATA_0
	{SEQUENCE_WAIT_MS, 10 , WORD_LEN, 0 },
	{0x0018, 0x0028       , WORD_LEN, 0 },// STANDBY_CONTROL_AND_STATUS
#endif





	
	{SEQUENCE_WAIT_MS, 10 , WORD_LEN, 0 },
	{0x98E,  0x8400       , WORD_LEN, 0 },//Refresh Sequencer Mode
	{0x990,  0x0006       , WORD_LEN, 0 },//		= 6
	{SEQUENCE_WAIT_MS, 20 , WORD_LEN, 0 },


{ SEQUENCE_END, 0x00, WORD_LEN, 0}
};

/* 720p 15fps @ 1280x720 */

static struct reginfo sensor_720p[]=
{
//Without bin/skipping. Same FOV width than other resolution
#if 1

	{0x098E, 0x4800, WORD_LEN, 0},       // y_start
	{0x0990, 0x0010, WORD_LEN, 0},       //    = 16
	{0x098E, 0x4802, WORD_LEN, 0},       // x_start
	{0x0990, 0x0018, WORD_LEN, 0},       //    = 24
	{0x098E, 0x4804, WORD_LEN, 0},       // y_end
	{0x0990, 0x062D, WORD_LEN, 0},       //    = 1581
	{0x098E, 0x4806, WORD_LEN, 0},       // x_end
	{0x0990, 0x0827, WORD_LEN, 0},       //    = 2087
	{0x098E, 0x4810, WORD_LEN, 0},       // Read Mode (A)
	{0x0990, 0x0024, WORD_LEN, 0},       //
	{0x098E, 0x6800, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x0500, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6802, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x02D0, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x480A, WORD_LEN, 0},       // Line Length (A)
	{0x0990, 0x0DC8, WORD_LEN, 0},       //      = 3528
	{0x098E, 0x6815, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_50hz 
	{0x0990, 0x0004, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6817, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_60hz 
	{0x0990, 0x0004, WORD_LEN, 0},       // MCU_DATA_0

	{0x098E, 0x6804, WORD_LEN, 0},       // FOV Width (A)
	{0x0990, 0x0800, WORD_LEN, 0},       //	   = 2048
	{0x098E, 0x6806, WORD_LEN, 0},       // FOV Height (A)
	{0x0990, 0x0480, WORD_LEN, 0},       //	   = 1152

	{0x098E, 0x8400, WORD_LEN, 0},       // Refresh Sequencer Mode
	{0x0990, 0x0006, WORD_LEN, 0},       //
	{SEQUENCE_WAIT_MS,20, WORD_LEN, 0},
#else
	{0x098E, 0x4802, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_X_ADDR_START]
	{0x0990, 0x0198, WORD_LEN, 0},         // 408
	{0x098E, 0x4800, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_Y_ADDR_START]
	{0x0990, 0x01B0, WORD_LEN, 0},         // 432
	{0x098E, 0x4806, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_X_ADDR_END]
	{0x0990, 0x06AC, WORD_LEN, 0},         // 1708
	{0x098E, 0x4804, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_Y_ADDR_END]
	{0x0990, 0x048F, WORD_LEN, 0},         // 1167
	{0x098E, 0x4810, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_READ_MODE]
	{0x0990, 0x006C, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x4810, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_READ_MODE]
	{0x0990, 0x002C, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x4810, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_READ_MODE]
	{0x0990, 0x0024, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x6800, WORD_LEN, 0},         // MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x0500, WORD_LEN, 0},         // 1280
	{0x098E, 0x6802, WORD_LEN, 0},         // MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x02D0, WORD_LEN, 0},         // 720
	{0x098E, 0x480A, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_LINE_LENGTH_PCLK]
	{0x0990, 0x0AA0, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x6815, WORD_LEN, 0},         // MCU_ADDRESS [PRI_A_CONFIG_FD_MAX_FDZONE_50HZ]
	{0x0990, 0x0004, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x6817, WORD_LEN, 0},         // MCU_ADDRESS [PRI_A_CONFIG_FD_MAX_FDZONE_60HZ]
	{0x0990, 0x0004, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},         // Refresh Sequencer Mode
	{0x0990, 0x0006, WORD_LEN, 0},         // 
#endif

	{SEQUENCE_END, 0x00}
};

/* 	1080p, 0x15fps, 0xyuv @1920x1080 */

static struct reginfo sensor_1080p[]=
{
	//{SEQUENCE_PROPERTY,SEQUENCE_CAPTURE},
	{SEQUENCE_END, 0x00}
};


/* 2048*1536 QXGA */
static struct reginfo sensor_qxga[] =
{
	{SEQUENCE_PROPERTY,SEQUENCE_CAPTURE},
	{0x098E, 0x6C00, WORD_LEN, 0},       // MCU_ADDRESS [PRI_B_IMAGE_WIDTH]
	{0x0990, 0x0800, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6C02, WORD_LEN, 0},       // MCU_ADDRESS [PRI_B_IMAGE_HEIGHT]
	{0x0990, 0x0600, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},       // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},       // MCU_DATA_0
	{SEQUENCE_WAIT_MS,20, WORD_LEN, 0},
	
	{SEQUENCE_END, 0x00}
};

/* 1600X1200 UXGA */
static struct reginfo sensor_uxga[] =
{
	#if 1
	{SEQUENCE_PROPERTY,SEQUENCE_CAPTURE},
	{0x098E, 0x6C00, WORD_LEN, 0},       // MCU_ADDRESS [PRI_B_IMAGE_WIDTH]
	{0x0990, 0x0640, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6C02, WORD_LEN, 0},       // MCU_ADDRESS [PRI_B_IMAGE_HEIGHT]
	{0x0990, 0x04B0, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},       // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},       // MCU_DATA_0
	{SEQUENCE_WAIT_MS,20, WORD_LEN, 0},
	#endif
	{SEQUENCE_END, 0x00}
};
/* 1280X1024 SXGA */
static struct reginfo sensor_sxga[] =
{
	//{SEQUENCE_PROPERTY,SEQUENCE_CAPTURE},
	{SEQUENCE_END, 0x00}
};
/*  1024X768 XGA */
static struct reginfo sensor_xga[] =
{
	#if 1
	{SEQUENCE_PROPERTY,SEQUENCE_CAPTURE},
	{0x098E, 0x6C00, WORD_LEN, 0},       // MCU_ADDRESS [PRI_B_IMAGE_WIDTH]
	{0x0990, 0x0400, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6C02, WORD_LEN, 0},       // MCU_ADDRESS [PRI_B_IMAGE_HEIGHT]
	{0x0990, 0x0300, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},		 // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},		 // MCU_DATA_0
	{SEQUENCE_WAIT_MS,20, WORD_LEN, 0},
	#endif
	{SEQUENCE_END, 0x00}
};

/* 800X600 SVGA*/
static struct reginfo sensor_svga[] =
{
	#if 1
	{0x098E, 0x4800, WORD_LEN, 0},       // y_start
	{0x0990, 0x0010, WORD_LEN, 0},       //    = 16
	{0x098E, 0x4802, WORD_LEN, 0},       // x_start
	{0x0990, 0x0018, WORD_LEN, 0},       //    = 24
	{0x098E, 0x4804, WORD_LEN, 0},       // y_end
	{0x0990, 0x062D, WORD_LEN, 0},       //    = 1581
	{0x098E, 0x4806, WORD_LEN, 0},       // x_end
	{0x0990, 0x0827, WORD_LEN, 0},       //    = 2087
	{0x098E, 0x4810, WORD_LEN, 0},       // Read Mode (A)
	{0x0990, 0x046C, WORD_LEN, 0},       //
	{0x098E, 0x6800, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x0320, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6802, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x0258, WORD_LEN, 0},       // MCU_DATA_0
    {0x098E, 0x480A, WORD_LEN, 0},       // Line Length (A)
    {0x0990, 0x0DC8, WORD_LEN, 0},       //      = 3528
    {0x098E, 0x6815, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_50hz 
    {0x0990, 0x0004, WORD_LEN, 0},       // MCU_DATA_0
    {0x098E, 0x6817, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_60hz 
    {0x0990, 0x0004, WORD_LEN, 0},       // MCU_DATA_0

	{0x098E, 0x6804, WORD_LEN, 0},       // FOV Width (A)
	{0x0990, 0x0800, WORD_LEN, 0},       //	   = 2048
	{0x098E, 0x6806, WORD_LEN, 0},       // FOV Height (A)
	{0x0990, 0x0600, WORD_LEN, 0},       //	   = 1536
#if 0
	{0x098E, 0x6815, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x000A, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6817, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x000C, WORD_LEN, 0},       // MCU_DATA_0
#endif

	{0x098E, 0x8400, WORD_LEN, 0},       // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},       // MCU_DATA_0
    	{SEQUENCE_WAIT_MS,20, WORD_LEN, 0},
  #endif
	{SEQUENCE_END, 0x00}
};

/* 640X480 VGA */
static struct reginfo sensor_vga[] =
{
#if 1
	//With bin xy
	{0x098E, 0x4800, WORD_LEN, 0},       // y_start
	{0x0990, 0x0010, WORD_LEN, 0},       //	   = 16
	{0x098E, 0x4802, WORD_LEN, 0},       // x_start
	{0x0990, 0x0010, WORD_LEN, 0},       //	   = 16
	{0x098E, 0x4804, WORD_LEN, 0},       // y_end
	{0x0990, 0x062D, WORD_LEN, 0},       //	   = 1581
	{0x098E, 0x4806, WORD_LEN, 0},       // x_end
	{0x0990, 0x082D, WORD_LEN, 0},       //	   = 2093
	{0x098E, 0x4810, WORD_LEN, 0},       // Read Mode (A)
	{0x0990, 0x046C, WORD_LEN, 0},       //
	{0x098E, 0x6800, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x0280, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6802, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x01E0, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x480A, WORD_LEN, 0},       // Line Length (A)
	{0x0990, 0x0A9B, WORD_LEN, 0},       //      = 2715
	{0x098E, 0x6815, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_50hz 
	{0x0990, 0x0004, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6817, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_60hz 
	{0x0990, 0x0004, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6804, WORD_LEN, 0},       // FOV Width (A)
	{0x0990, 0x0800, WORD_LEN, 0},       //	   = 2048
	{0x098E, 0x6806, WORD_LEN, 0},       // FOV Height (A)
	{0x0990, 0x0600, WORD_LEN, 0},       //	   = 1536
	{0x098E, 0x8400, WORD_LEN, 0},       // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},       // MCU_DATA_0
#else

	{0x098E, 0x4802, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_X_ADDR_START]
	{0x0990, 0x0198, WORD_LEN, 0},         // 408
	{0x098E, 0x4800, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_Y_ADDR_START]
	{0x0990, 0x01B0, WORD_LEN, 0},         // 432
	{0x098E, 0x4806, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_X_ADDR_END]
	{0x0990, 0x042D, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x4804, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_Y_ADDR_END]
	{0x0990, 0x03A0, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x4810, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_READ_MODE]
	{0x0990, 0x006C, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x4810, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_READ_MODE]
	{0x0990, 0x002C, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x4810, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_READ_MODE]
	{0x0990, 0x0024, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x6800, WORD_LEN, 0},         // MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x0280, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x6802, WORD_LEN, 0},         // MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x01E0, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x480A, WORD_LEN, 0},         // MCU_ADDRESS [CAM1_CTX_A_LINE_LENGTH_PCLK]
	{0x0990, 0x0820, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x6815, WORD_LEN, 0},         // MCU_ADDRESS [PRI_A_CONFIG_FD_MAX_FDZONE_50HZ]
	{0x0990, 0x0004, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x6817, WORD_LEN, 0},         // MCU_ADDRESS [PRI_A_CONFIG_FD_MAX_FDZONE_60HZ]
	{0x0990, 0x0004, WORD_LEN, 0},         // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},         // Refresh Sequencer Mode
	{0x0990, 0x0006, WORD_LEN, 0},         // 
#endif
   	{SEQUENCE_WAIT_MS,20, WORD_LEN, 0},
    	{SEQUENCE_END, 0x00}
};

/* 352X288 CIF */
static struct reginfo sensor_cif[] =
{
#if 1
	{0x098E, 0x4800, WORD_LEN, 0},       // y_start
	{0x0990, 0x0010, WORD_LEN, 0},       //    = 16
	{0x098E, 0x4802, WORD_LEN, 0},       // x_start
	{0x0990, 0x0018, WORD_LEN, 0},       //    = 24
	{0x098E, 0x4804, WORD_LEN, 0},       // y_end
	{0x0990, 0x062D, WORD_LEN, 0},       //    = 1581
	{0x098E, 0x4806, WORD_LEN, 0},       // x_end
	{0x0990, 0x0827, WORD_LEN, 0},       //    = 2087
	{0x098E, 0x4810, WORD_LEN, 0},       // Read Mode (A)
	{0x0990, 0x046C, WORD_LEN, 0},       //
	{0x098E, 0x480A, WORD_LEN, 0},       // Line Length (A)
	{0x0990, 0x0DC8, WORD_LEN, 0},       //      = 3528
	{0x098E, 0x6815, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_50hz 
	{0x0990, 0x0004, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6817, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_60hz 
	{0x0990, 0x0004, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6804, WORD_LEN, 0},       // FOV Width (A)
	{0x098E, 0x6804, WORD_LEN, 0},       // FOV Width (A)
	{0x0990, 0x0800, WORD_LEN, 0},       //	   = 1024
	{0x098E, 0x6806, WORD_LEN, 0},       // FOV Height (A)
	{0x0990, 0x0600, WORD_LEN, 0},       //	   = 768
	{0x0990, 0x0800, WORD_LEN, 0},       //	   = 2048
	{0x098E, 0x6806, WORD_LEN, 0},       // FOV Height (A)
	{0x0990, 0x0600, WORD_LEN, 0},       //	   = 1536
	{0x098E, 0x6800, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x0160, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6802, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x0120, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},       // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},       // MCU_DATA_0
#endif
	{SEQUENCE_END, 0x00}
};

/* 320*240 QVGA */
static  struct reginfo sensor_qvga[] =
{
#if 1
	{0x098E, 0x4800, WORD_LEN, 0},       // y_start
	{0x0990, 0x0010, WORD_LEN, 0},       //    = 16
	{0x098E, 0x4802, WORD_LEN, 0},       // x_start
	{0x0990, 0x0018, WORD_LEN, 0},       //    = 24
	{0x098E, 0x4804, WORD_LEN, 0},       // y_end
	{0x0990, 0x062D, WORD_LEN, 0},       //    = 1581
	{0x098E, 0x4806, WORD_LEN, 0},       // x_end
	{0x0990, 0x0827, WORD_LEN, 0},       //    = 2087
	{0x098E, 0x4810, WORD_LEN, 0},       // Read Mode (A)
	{0x0990, 0x046C, WORD_LEN, 0},       //
	{0x098E, 0x480A, WORD_LEN, 0},       // Line Length (A)
	{0x0990, 0x0DC8, WORD_LEN, 0},       //      = 3528
	{0x098E, 0x6815, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_50hz 
	{0x0990, 0x0004, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6817, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_60hz 
	{0x0990, 0x0004, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6804, WORD_LEN, 0},       // FOV Width (A)
	{0x0990, 0x0800, WORD_LEN, 0},       //	   = 2048
	{0x098E, 0x6806, WORD_LEN, 0},       // FOV Height (A)
	{0x0990, 0x0600, WORD_LEN, 0},       //	   = 1536
	{0x098E, 0x6800, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x0140, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6802, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x00F0, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},       // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},       // MCU_DATA_0
	{SEQUENCE_WAIT_MS,100, WORD_LEN, 0},
#endif
	{SEQUENCE_END, 0x00}
};
#if 0
/* 720*480  */
static  struct reginfo sensor_240x160[] =
{
	{0x098E, 0x6800, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x02D0, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6802, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x01E0, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},       // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},       // MCU_DATA_0
    	{SEQUENCE_WAIT_MS,100, WORD_LEN, 0},
	{SEQUENCE_END, 0x00}
};

/* 240*160  */
static  struct reginfo sensor_240x160[] =
{
	{0x098E, 0x6800, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x00F0, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6802, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x00A0, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},       // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},       // MCU_DATA_0
    	{SEQUENCE_WAIT_MS,100, WORD_LEN, 0},
	{SEQUENCE_END, 0x00}
};
#endif
/* 176X144 QCIF*/
static struct reginfo sensor_qcif[] =
{
#if 1
	{0x098E, 0x4800, WORD_LEN, 0},       // y_start
	{0x0990, 0x0010, WORD_LEN, 0},       //    = 16
	{0x098E, 0x4802, WORD_LEN, 0},       // x_start
	{0x0990, 0x0018, WORD_LEN, 0},       //    = 24
	{0x098E, 0x4804, WORD_LEN, 0},       // y_end
	{0x0990, 0x062D, WORD_LEN, 0},       //    = 1581
	{0x098E, 0x4806, WORD_LEN, 0},       // x_end
	{0x0990, 0x0827, WORD_LEN, 0},       //    = 2087
	{0x098E, 0x4810, WORD_LEN, 0},       // Read Mode (A)
	{0x0990, 0x046C, WORD_LEN, 0},       //
	{0x098E, 0x480A, WORD_LEN, 0},       // Line Length (A)
	{0x0990, 0x0DC8, WORD_LEN, 0},       //      = 3528
	{0x098E, 0x6815, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_50hz 
	{0x0990, 0x0004, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6817, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_60hz 
	{0x0990, 0x0004, WORD_LEN, 0},       // MCU_DATA_0

	{0x098E, 0x6804, WORD_LEN, 0},       // FOV Width (A)
	{0x0990, 0x0800, WORD_LEN, 0},       //	   = 2048
	{0x098E, 0x6806, WORD_LEN, 0},       // FOV Height (A)
	{0x0990, 0x0600, WORD_LEN, 0},       //	   = 1536
	{0x098E, 0x6800, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_WIDTH]
	{0x0990, 0x0B0, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6802, WORD_LEN, 0},       // MCU_ADDRESS [PRI_A_IMAGE_HEIGHT]
	{0x0990, 0x0090, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},       // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},       // MCU_DATA_0
	{SEQUENCE_WAIT_MS,100, WORD_LEN, 0},
#endif
	{SEQUENCE_END, 0x00}
};
#endif
static  struct reginfo sensor_Preview2Capture[]=
{
	//capture2preview

	{0x098E, 0xEC09, WORD_LEN, 0}, 
	{0x0990, 0x0000, WORD_LEN, 0}, 
	{0x098E, 0x8400, WORD_LEN, 0}, 
	{0x0990, 0x0002, WORD_LEN, 0}, 
	{0x3400, 0x7A24, WORD_LEN, 0}, 
		

	//Do not wait here but in the check loop
	{SEQUENCE_WAIT_MS,50, WORD_LEN, 0},

	{SEQUENCE_END, 0x00}
};
static  struct reginfo sensor_Preview2Capture_check[]=
{

	{0x098E, 0x8401, WORD_LEN, 0}, 

{ SEQUENCE_END, 0x00, WORD_LEN, 0}
};


static  struct reginfo sensor_Capture2Preview[]=
{
	//snap2preview
	{0x098E, 0xEC09, WORD_LEN, 0}, 
	{0x0990, 0x0005, WORD_LEN, 0}, 
	{0x098E, 0x8400, WORD_LEN, 0}, 
	{0x0990, 0x0001, WORD_LEN, 0}, 
	//Do not wait here but in the check loop
	//{SEQUENCE_WAIT_MS,50, WORD_LEN, 0},
	{SEQUENCE_END, 0x00}
};
static  struct reginfo sensor_ClrFmt_YUYV[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_ClrFmt_UYVY[]=
{
	{SEQUENCE_END, 0x00}
};


#if CONFIG_SENSOR_WhiteBalance
static  struct reginfo sensor_WhiteB_Auto[]=
{
	//Auto
	{0x098E, 0x6848, WORD_LEN, 0},  	// MCU_ADDRESS [AWB_ALGO]
	{0x0990, 0x003F, WORD_LEN, 0},  	// MCU_DATA_0
  //
	{0x098E, 0x8400, WORD_LEN, 0},  	// MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},  	// MCU_DATA_0
	
	{SEQUENCE_END, 0x00}
};
/* Cloudy Colour Temperature : 6500K - 8000K  */
static  struct reginfo sensor_WhiteB_Cloudy[]=
{
	//[V.       DL 7500]
	
		{0x098E, 0x6848, WORD_LEN, 0}, 
		{0x0990, 0x0000, WORD_LEN, 0}, 
		{0x098E, 0x8400, WORD_LEN, 0}, 
		{0x0990, 0x0006, WORD_LEN, 0}, 
		
		{0x098E, 0xAC3B, WORD_LEN, 0}, 
		{0x0990, 0x0041, WORD_LEN, 0}, 
		{0x098E, 0xAC3C, WORD_LEN, 0}, 
		{0x0990, 0x0058, WORD_LEN, 0}, 

/*
   {0x098E, 0x6848, WORD_LEN, 0}, 
   {0x0990, 0x0000, WORD_LEN, 0}, 
   {0x098E, 0x6865, WORD_LEN, 0}, 
   {0x0990, 0x0000, WORD_LEN, 0}, 
   {0x098E, 0x8400, WORD_LEN, 0}, 
   {0x0990, 0x0006, WORD_LEN, 0}, 
   
   {0x098E, 0xAC3B, WORD_LEN, 0}, 
   {0x0990, 0x0070, WORD_LEN, 0}, 
   {0x098E, 0xAC3C, WORD_LEN, 0}, 
   {0x0990, 0x0029, WORD_LEN, 0}, 
*/
	{SEQUENCE_END, 0x00}
};
/* ClearDay Colour Temperature : 5000K - 6500K  */
static  struct reginfo sensor_WhiteB_ClearDay[]=
{
	//[IV       Day Light]
/*	
   {0x098E, 0x6848, WORD_LEN, 0}, 
   {0x0990, 0x0000, WORD_LEN, 0}, 
   {0x098E, 0x8400, WORD_LEN, 0}, 
   {0x0990, 0x0006, WORD_LEN, 0}, 
   
   {0x098E, 0xAC3B, WORD_LEN, 0}, 
   {0x0990, 0x0041, WORD_LEN, 0}, 
   {0x098E, 0xAC3C, WORD_LEN, 0}, 
   {0x0990, 0x0058, WORD_LEN, 0}, 
*/
		{0x098E, 0x6848, WORD_LEN, 0}, 
		{0x0990, 0x0000, WORD_LEN, 0}, 
		{0x098E, 0x8400, WORD_LEN, 0}, 
		{0x0990, 0x0006, WORD_LEN, 0}, 
		
		{0x098E, 0xAC3B, WORD_LEN, 0}, 
		{0x0990, 0x0048, WORD_LEN, 0}, 
		{0x098E, 0xAC3C, WORD_LEN, 0}, 
		{0x0990, 0x0036, WORD_LEN, 0}, 


	{SEQUENCE_END, 0x00}
};
/* Office Colour Temperature : 3500K - 5000K  */
static  struct reginfo sensor_WhiteB_TungstenLamp1[]=
{
	//[Manual WB-CWF]
		{0x098E, 0x6848, WORD_LEN, 0}, 
		{0x0990, 0x0000, WORD_LEN, 0}, 
		{0x098E, 0x6865, WORD_LEN, 0}, 
		{0x0990, 0x0000, WORD_LEN, 0}, 
		{0x098E, 0x8400, WORD_LEN, 0}, 
		{0x0990, 0x0006, WORD_LEN, 0}, 
		
		{0x098E, 0xAC3B, WORD_LEN, 0}, 
		{0x0990, 0x0070, WORD_LEN, 0}, 
		{0x098E, 0xAC3C, WORD_LEN, 0}, 
		{0x0990, 0x0029, WORD_LEN, 0}, 

	{SEQUENCE_END, 0x00}
};
/* Home Colour Temperature : 2500K - 3500K  */
static  struct reginfo sensor_WhiteB_TungstenLamp2[]=
{
	//[Manual WB-A28]
	/*
   {0x098E, 0x6848, WORD_LEN, 0}, 
   {0x0990, 0x0000, WORD_LEN, 0}, 
   {0x098E, 0x8400, WORD_LEN, 0}, 
   {0x0990, 0x0006, WORD_LEN, 0}, 
   
   {0x098E, 0xAC3B, WORD_LEN, 0}, 
   {0x0990, 0x005F, WORD_LEN, 0}, 
   {0x098E, 0xAC3C, WORD_LEN, 0}, 
   {0x0990, 0x002E, WORD_LEN, 0}, 
*/
		{0x098E, 0x6848, WORD_LEN, 0}, 
		{0x0990, 0x0000, WORD_LEN, 0}, 
		{0x098E, 0x8400, WORD_LEN, 0}, 
		{0x0990, 0x0006, WORD_LEN, 0}, 
		
		{0x098E, 0xAC3B, WORD_LEN, 0}, 
		{0x0990, 0x005F, WORD_LEN, 0}, 
		{0x098E, 0xAC3C, WORD_LEN, 0}, 
		{0x0990, 0x002E, WORD_LEN, 0}, 


	{SEQUENCE_END, 0x00}
};
static struct reginfo *sensor_WhiteBalanceSeqe[] = {sensor_WhiteB_Auto, sensor_WhiteB_TungstenLamp1,sensor_WhiteB_TungstenLamp2,
    sensor_WhiteB_ClearDay, sensor_WhiteB_Cloudy,NULL,
};
#endif

#if CONFIG_SENSOR_Brightness
static  struct reginfo sensor_Brightness0[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Brightness1[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Brightness2[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Brightness3[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Brightness4[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Brightness5[]=
{
	{SEQUENCE_END, 0x00}
};
static struct reginfo *sensor_BrightnessSeqe[] = {sensor_Brightness0, sensor_Brightness1, sensor_Brightness2, sensor_Brightness3,
    sensor_Brightness4, sensor_Brightness5,NULL,
};

#endif

#if CONFIG_SENSOR_Effect
static  struct reginfo sensor_Effect_Normal[] =
{
	{0x098E, 0xE887, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_SYSCTRL_SELECT_FX]
	{0x0990, 0x0000, WORD_LEN, 0}, 	// MCU_DATA_0
	{0x098E, 0xEC87, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SELECT_FX]
	{0x0990, 0x0000, WORD_LEN, 0}, 	// MCU_DATA_0
  //                                      
	{0x098E, 0x8400, WORD_LEN, 0}, 	// MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0}, 	// MCU_DATA_0
	{SEQUENCE_END, 0x00}
};

/*static  struct reginfo sensor_Effect_WandB[] =
{
	{SEQUENCE_END, 0x00}
};*/

static  struct reginfo sensor_Effect_Sepia[] =
{
	{0x098E, 0xE887, WORD_LEN, 0}, // MCU_ADDRESS [PRI_A_CONFIG_SYSCTRL_SEPIA_CB]
	{0x0990, 0x0002, WORD_LEN, 0}, // MCU_DATA_0
	{0x098E, 0xEC87, WORD_LEN, 0}, // MCU_ADDRESS [PRI_A_CONFIG_SYSCTRL_SEPIA_CR]
	{0x0990, 0x0002, WORD_LEN, 0}, // MCU_DATA_0
	{0x098E, 0xE889, WORD_LEN, 0}, // MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SEPIA_CB]
	{0x0990, 0x001E, WORD_LEN, 0}, // MCU_DATA_0
	{0x098E, 0xE88A, WORD_LEN, 0}, // MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SEPIA_CR]
	{0x0990, 0x009C, WORD_LEN, 0}, // MCU_DATA_0
	{0x098E, 0xEC89, WORD_LEN, 0}, // MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SEPIA_CB]
	{0x0990, 0x001E, WORD_LEN, 0}, // MCU_DATA_0
	{0x098E, 0xEC8A, WORD_LEN, 0}, // MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SEPIA_CR]
	{0x0990, 0x009C, WORD_LEN, 0}, // MCU_DATA_0

	{0x098E, 0x8400, WORD_LEN, 0}, // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0}, // MCU_DATA_0
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Effect_Negative[] =
{
	{0x098E, 0xE887, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_SYSCTRL_SELECT_FX]
	{0x0990, 0x0003, WORD_LEN, 0}, 	// MCU_DATA_0
	{0x098E, 0xEC87, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SELECT_FX]
	{0x0990, 0x0003, WORD_LEN, 0}, 	// MCU_DATA_0
  //                                   
	{0x098E, 0x8400, WORD_LEN, 0}, 	// MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0}, 	// MCU_DATA_0

	{SEQUENCE_END, 0x00}
};
static  struct reginfo sensor_Effect_Bluish[] =
{
	{0x098E, 0xE887, WORD_LEN, 0},	// MCU_ADDRESS [PRI_A_CONFIG_SYSCTRL_SEPIA_CB]
	{0x0990, 0x0002, WORD_LEN, 0},	// MCU_DATA_0
	{0x098E, 0xEC87, WORD_LEN, 0},	// MCU_ADDRESS [PRI_A_CONFIG_SYSCTRL_SEPIA_CR]
	{0x0990, 0x0002, WORD_LEN, 0},	// MCU_DATA_0                         
	{0x098E, 0xE889, WORD_LEN, 0},	// MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SEPIA_CB]
	{0x0990, 0x0022, WORD_LEN, 0},	// MCU_DATA_0                         
	{0x098E, 0xE88A, WORD_LEN, 0},	// MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SEPIA_CR]
	{0x0990, 0x000C, WORD_LEN, 0},	// MCU_DATA_0                         
	{0x098E, 0xEC89, WORD_LEN, 0},	// MCU_ADDRESS [PRI_A_CONFIG_SYSCTRL_SELECT_FX]
	{0x0990, 0x0022, WORD_LEN, 0},	// MCU_DATA_0                         
	{0x098E, 0xEC8A, WORD_LEN, 0},	// MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SELECT_FX]
	{0x0990, 0x000C, WORD_LEN, 0},	// MCU_DATA_0                         
  //                                                              
	{0x098E, 0x8400, WORD_LEN, 0},	// MCU_ADDRESS [SEQ_CMD]              
	{0x0990, 0x0006, WORD_LEN, 0},	// MCU_DATA_0  
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Effect_Green[] =
{
	{0x098E, 0xE887, WORD_LEN, 0},	// MCU_ADDRESS [PRI_A_CONFIG_SYSCTRL_SEPIA_CB]
	{0x0990, 0x0002, WORD_LEN, 0},	// MCU_DATA_0
	{0x098E, 0xEC87, WORD_LEN, 0},	// MCU_ADDRESS [PRI_A_CONFIG_SYSCTRL_SEPIA_CR]
	{0x0990, 0x0002, WORD_LEN, 0},	// MCU_DATA_0
	{0x098E, 0xE889, WORD_LEN, 0},	// MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SEPIA_CB]
	{0x0990, 0x00D8, WORD_LEN, 0},	// MCU_DATA_0
	{0x098E, 0xE88A, WORD_LEN, 0},	// MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SEPIA_CR]
	{0x0990, 0x00BA, WORD_LEN, 0},	// MCU_DATA_0
	{0x098E, 0xEC89, WORD_LEN, 0},	// MCU_ADDRESS [PRI_A_CONFIG_SYSCTRL_SELECT_FX]
	{0x0990, 0x00D8, WORD_LEN, 0},	// MCU_DATA_0
	{0x098E, 0xEC8A, WORD_LEN, 0},	// MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SELECT_FX]
	{0x0990, 0x00BA, WORD_LEN, 0},	// MCU_DATA_0
  //                                       
	{0x098E, 0x8400, WORD_LEN, 0},	// MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},	// MCU_DATA_0
	{SEQUENCE_END, 0x00}
};

static struct reginfo sensor_Effect_Solarize[] =
{
	{0x098E, 0xE887, WORD_LEN, 0},	// MCU_ADDRESS [PRI_A_CONFIG_SYSCTRL_SELECT_FX]
	{0x0990, 0x0004, WORD_LEN, 0},	// MCU_DATA_0
	{0x098E, 0xEC87, WORD_LEN, 0},	// MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SELECT_FX]
	{0x0990, 0x0004, WORD_LEN, 0},	// MCU_DATA_0
  //                                       
	{0x098E, 0x8400, WORD_LEN, 0},	// MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},	// MCU_DATA_0	
	{SEQUENCE_END, 0x00}
};


static struct reginfo sensor_Effect_Grayscale[] =
{
	{0x098E, 0xE887, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_SYSCTRL_SELECT_FX]
	{0x0990, 0x0005, WORD_LEN, 0}, 	// MCU_DATA_0
	{0x098E, 0xEC87, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_B_CONFIG_SYSCTRL_SELECT_FX]
	{0x0990, 0x0005, WORD_LEN, 0}, 	// MCU_DATA_0
  //                                      
	{0x098E, 0x8400, WORD_LEN, 0}, 	// MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0}, 	// MCU_DATA_0
	{SEQUENCE_END, 0x00}
};


static struct reginfo *sensor_EffectSeqe[] = {sensor_Effect_Normal, sensor_Effect_Negative,sensor_Effect_Sepia,
    sensor_Effect_Solarize,sensor_Effect_Bluish,sensor_Effect_Green,sensor_Effect_Grayscale,NULL,
};
#endif
#if CONFIG_SENSOR_Exposure
static  struct reginfo sensor_Exposure0[]=
{
	{0x337E, 0x7000, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AE_RULE_BASE_TARGET]
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Exposure1[]=
{
	{0x337E, 0x6000, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AE_RULE_BASE_TARGET]
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Exposure2[]=
{
	{0x337E, 0x4000, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AE_RULE_BASE_TARGET]
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Exposure3[]=
{
	{0x337E, 0x2000, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AE_RULE_BASE_TARGET]
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Exposure4[]=
{
	{0x337E, 0x0000, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AE_RULE_BASE_TARGET]
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Exposure5[]=
{
	{0x337E, 0xE000, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AE_RULE_BASE_TARGET]
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Exposure6[]=
{
	{0x337E, 0xC000, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AE_RULE_BASE_TARGET]
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Exposure7[]=
{
	{0x337E, 0xA000, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AE_RULE_BASE_TARGET]
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Exposure8[]=
{
	{0x337E, 0x8000, WORD_LEN, 0}, 	// MCU_ADDRESS [PRI_A_CONFIG_AE_RULE_BASE_TARGET]
	{SEQUENCE_END, 0x00}
};

#if 0
static struct reginfo *sensor_ExposureSeqe[] = {/*sensor_Exposure0,*/ sensor_Exposure1, sensor_Exposure2, sensor_Exposure3,
    sensor_Exposure4, sensor_Exposure5,sensor_Exposure6,sensor_Exposure7,/*sensor_Exposure8,*/NULL,
};
#endif
static struct reginfo *sensor_ExposureSeqe[] = {/*sensor_Exposure8,*/ sensor_Exposure7, sensor_Exposure6, sensor_Exposure5,
    sensor_Exposure4, sensor_Exposure3,sensor_Exposure2,sensor_Exposure1,/*sensor_Exposure0,*/NULL,
};

#endif
#if CONFIG_SENSOR_Saturation
static  struct reginfo sensor_Saturation0[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Saturation1[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Saturation2[]=
{
	{SEQUENCE_END, 0x00}
};
static struct reginfo *sensor_SaturationSeqe[] = {sensor_Saturation0, sensor_Saturation1, sensor_Saturation2, NULL,};

#endif
#if CONFIG_SENSOR_Contrast
static  struct reginfo sensor_Contrast0[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Contrast1[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Contrast2[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Contrast3[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Contrast4[]=
{
	{SEQUENCE_END, 0x00}
};


static  struct reginfo sensor_Contrast5[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_Contrast6[]=
{
	{SEQUENCE_END, 0x00}
};
static struct reginfo *sensor_ContrastSeqe[] = {sensor_Contrast0, sensor_Contrast1, sensor_Contrast2, sensor_Contrast3,
    sensor_Contrast4, sensor_Contrast5, sensor_Contrast6, NULL,
};

#endif
#if CONFIG_SENSOR_Mirror
static  struct reginfo sensor_MirrorOn[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_MirrorOff[]=
{
	{SEQUENCE_END, 0x00}
};
static struct reginfo *sensor_MirrorSeqe[] = {sensor_MirrorOff, sensor_MirrorOn,NULL,};
#endif
#if CONFIG_SENSOR_Flip
static  struct reginfo sensor_FlipOn[]=
{
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_FlipOff[]=
{
	{SEQUENCE_END, 0x00}
};
static struct reginfo *sensor_FlipSeqe[] = {sensor_FlipOff, sensor_FlipOn,NULL,};

#endif
#if CONFIG_SENSOR_Scene
static  struct reginfo sensor_SceneAuto[] =
{

	{0x098E, 0x6815, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_50hz 
	{0x0990, 0x0007, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6817, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_60hz 
	{0x0990, 0x0007, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},       // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},       // MCU_DATA_0
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_SceneNight[] =
{
	{0x098E, 0x6815, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_50hz 
	{0x0990, 0x000A, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6817, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_60hz 
	{0x0990, 0x000C, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},       // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},       // MCU_DATA_0
	{SEQUENCE_END, 0x00}
};

static  struct reginfo sensor_SceneSports[] =
{

	{0x098E, 0x6815, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_50hz 
	{0x0990, 0x0005, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x6817, WORD_LEN, 0},       // pri_a_config_fd_max_fdzone_60hz 
	{0x0990, 0x0005, WORD_LEN, 0},       // MCU_DATA_0
	{0x098E, 0x8400, WORD_LEN, 0},       // MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0006, WORD_LEN, 0},       // MCU_DATA_0
	{SEQUENCE_END, 0x00}
};

static struct reginfo *sensor_SceneSeqe[] = {sensor_SceneAuto, sensor_SceneNight, sensor_SceneSports, NULL,};

#endif
#if CONFIG_SENSOR_DigitalZoom
static struct reginfo sensor_Zoom0[] =
{
	{SEQUENCE_END, 0x00}
};

static struct reginfo sensor_Zoom1[] =
{
	{SEQUENCE_END, 0x00}
};

static struct reginfo sensor_Zoom2[] =
{
	{SEQUENCE_END, 0x00}
};


static struct reginfo sensor_Zoom3[] =
{
	{SEQUENCE_END, 0x00}
};
static struct reginfo *sensor_ZoomSeqe[] = {sensor_Zoom0, sensor_Zoom1, sensor_Zoom2, sensor_Zoom3, NULL};
#endif
static const struct v4l2_querymenu sensor_menus[] =
{
	#if CONFIG_SENSOR_WhiteBalance
    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 0,  .name = "auto",  .reserved = 0, }, {  .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 1, .name = "incandescent",  .reserved = 0,},
    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 2,  .name = "fluorescent", .reserved = 0,}, {  .id = V4L2_CID_DO_WHITE_BALANCE, .index = 3,  .name = "daylight", .reserved = 0,},
    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 4,  .name = "cloudy-daylight", .reserved = 0,},
    #endif

	#if CONFIG_SENSOR_Effect
    { .id = V4L2_CID_EFFECT,  .index = 0,  .name = "none",  .reserved = 0, }, {  .id = V4L2_CID_EFFECT,  .index = 1, .name = "negative",  .reserved = 0,},
    { .id = V4L2_CID_EFFECT,  .index = 2,  .name = "sepia", .reserved = 0,}, {  .id = V4L2_CID_EFFECT, .index = 3,  .name = "solarize", .reserved = 0,},
     { .id = V4L2_CID_EFFECT,  .index = 4,  .name = "bluish",  .reserved = 0, }, {  .id = V4L2_CID_EFFECT,  .index = 5, .name = "green",  .reserved = 0,},
    { .id = V4L2_CID_EFFECT,  .index = 6,  .name = "graycale", .reserved = 0,}, 
    #endif
#if CONFIG_SENSOR_Exposure
      /*{ .id = V4L2_CID_EXPOSURE,  .index = 0,  .name = "-4",  .reserved = 0, },*/ {  .id = V4L2_CID_EXPOSURE,  .index = 0, .name = "-3",  .reserved = 0,},
        { .id = V4L2_CID_EXPOSURE,  .index = 1,  .name = "-2", .reserved = 0,}, {  .id = V4L2_CID_EXPOSURE, .index = 2,  .name = "-1", .reserved = 0,},
        { .id = V4L2_CID_EXPOSURE,  .index = 3,  .name = "0",  .reserved = 0, }, {  .id = V4L2_CID_EXPOSURE,  .index = 4, .name = "+1",  .reserved = 0,},
	{ .id = V4L2_CID_EXPOSURE,  .index = 5,  .name = "+2",  .reserved = 0, }, {  .id = V4L2_CID_EXPOSURE,  .index = 6, .name = "+3",  .reserved = 0,},
	/*{ .id = V4L2_CID_EXPOSURE,  .index = 8,  .name = "+4",  .reserved = 0, },*/
#endif
	#if CONFIG_SENSOR_Scene
    { .id = V4L2_CID_SCENE,  .index = 0, .name = "auto", .reserved = 0,} ,{ .id = V4L2_CID_SCENE,  .index = 1,  .name = "night", .reserved = 0,},{ .id = V4L2_CID_SCENE,  .index = 2,  .name = "sports", .reserved = 0,},
    #endif

	#if CONFIG_SENSOR_Flash
	{ .id = V4L2_CID_FLASH,  .index = 0,  .name = "off",  .reserved = 0, }, {  .id = V4L2_CID_FLASH,  .index = 1, .name = "auto",  .reserved = 0,},
   	{ .id = V4L2_CID_FLASH,  .index = 2,  .name = "on", .reserved = 0,}, {  .id = V4L2_CID_FLASH, .index = 3,  .name = "torch", .reserved = 0,},
  
    //{ .id = V4L2_CID_FLASH,  .index = 0,  .name = "off",  .reserved = 0, }, {  .id = V4L2_CID_FLASH,  .index = 1, .name = "on",  .reserved = 0,},
    #endif
};

static  struct v4l2_queryctrl sensor_controls[] =
{
	#if CONFIG_SENSOR_WhiteBalance
    {
        .id		= V4L2_CID_DO_WHITE_BALANCE,
        .type		= V4L2_CTRL_TYPE_MENU,
        .name		= "White Balance Control",
        .minimum	= 0,
        .maximum	= 4,
        .step		= 1,
        .default_value = 0,
    },
    #endif

	#if CONFIG_SENSOR_Brightness
	{
        .id		= V4L2_CID_BRIGHTNESS,
        .type		= V4L2_CTRL_TYPE_INTEGER,
        .name		= "Brightness Control",
        .minimum	= -3,
        .maximum	= 2,
        .step		= 1,
        .default_value = 0,
    },
    #endif

	#if CONFIG_SENSOR_Effect
	{
        .id		= V4L2_CID_EFFECT,
        .type		= V4L2_CTRL_TYPE_MENU,
        .name		= "Effect Control",
        .minimum	= 0,
        .maximum	= 6,
        .step		= 1,
        .default_value = 0,
    },
	#endif

	#if CONFIG_SENSOR_Exposure
	{
        .id		= V4L2_CID_EXPOSURE,
        .type		= V4L2_CTRL_TYPE_INTEGER,
        .name		= "Exposure Control",
        .minimum	= -3,
        .maximum	= 3,
        .step		= 1,
        .default_value = 0,
    },
	#endif

	#if CONFIG_SENSOR_Saturation
	{
        .id		= V4L2_CID_SATURATION,
        .type		= V4L2_CTRL_TYPE_INTEGER,
        .name		= "Saturation Control",
        .minimum	= 0,
        .maximum	= 2,
        .step		= 1,
        .default_value = 0,
    },
    #endif

	#if CONFIG_SENSOR_Contrast
	{
        .id		= V4L2_CID_CONTRAST,
        .type		= V4L2_CTRL_TYPE_INTEGER,
        .name		= "Contrast Control",
        .minimum	= -3,
        .maximum	= 3,
        .step		= 1,
        .default_value = 0,
    },
	#endif

	#if CONFIG_SENSOR_Mirror
	{
        .id		= V4L2_CID_HFLIP,
        .type		= V4L2_CTRL_TYPE_BOOLEAN,
        .name		= "Mirror Control",
        .minimum	= 0,
        .maximum	= 1,
        .step		= 1,
        .default_value = 1,
    },
    #endif

	#if CONFIG_SENSOR_Flip
	{
        .id		= V4L2_CID_VFLIP,
        .type		= V4L2_CTRL_TYPE_BOOLEAN,
        .name		= "Flip Control",
        .minimum	= 0,
        .maximum	= 1,
        .step		= 1,
        .default_value = 1,
    },
    #endif

	#if CONFIG_SENSOR_Scene
    {
        .id		= V4L2_CID_SCENE,
        .type		= V4L2_CTRL_TYPE_MENU,
        .name		= "Scene Control",
        .minimum	= 0,
        .maximum	= 2,
        .step		= 1,
        .default_value = 0,
    },
    #endif

	#if CONFIG_SENSOR_DigitalZoom
    {
        .id		= V4L2_CID_ZOOM_RELATIVE,
        .type		= V4L2_CTRL_TYPE_INTEGER,
        .name		= "DigitalZoom Control",
        .minimum	= -1,
        .maximum	= 1,
        .step		= 1,
        .default_value = 0,
    }, {
        .id		= V4L2_CID_ZOOM_ABSOLUTE,
        .type		= V4L2_CTRL_TYPE_INTEGER,
        .name		= "DigitalZoom Control",
        .minimum	= 0,
        .maximum	= 3,
        .step		= 1,
        .default_value = 0,
    },
    #endif

	#if CONFIG_SENSOR_Focus
/*	{
        .id		= V4L2_CID_FOCUS_RELATIVE,
        .type		= V4L2_CTRL_TYPE_INTEGER,
        .name		= "Focus Control",
        .minimum	= -1,
        .maximum	= 1,
        .step		= 1,
        .default_value = 0,
    }, {
        .id		= V4L2_CID_FOCUS_ABSOLUTE,
        .type		= V4L2_CTRL_TYPE_INTEGER,
        .name		= "Focus Control",
        .minimum	= 0,
        .maximum	= 255,
        .step		= 1,
        .default_value = 125,
    },
*/	
	{
        .id		= V4L2_CID_FOCUSZONE,
        .type		= V4L2_CTRL_TYPE_INTEGER,
        .name		= "FocusZone Control",
        .minimum	= -1,
        .maximum	= 1,
        .step		= 1,
        .default_value = 0,
    },{
        .id		= V4L2_CID_FOCUS_AUTO,
        .type		= V4L2_CTRL_TYPE_BOOLEAN,
        .name		= "Focus Control",
        .minimum	= 0,
        .maximum	= 1,
        .step		= 1,
        .default_value = 0,
    },
    {
        .id		= V4L2_CID_FOCUS_CONTINUOUS,
        .type		= V4L2_CTRL_TYPE_BOOLEAN,
        .name		= "Focus Control",
        .minimum	= 0,
        .maximum	= 1,
        .step		= 1,
        .default_value = 0,
    },
    #endif

	#if CONFIG_SENSOR_Flash
	{
        .id		= V4L2_CID_FLASH,
        .type		= V4L2_CTRL_TYPE_MENU,
       // .type		= V4L2_CTRL_TYPE_BOOLEAN,
        .name		= "Flash Control",
        .minimum	= 0,
        .maximum	= 3,
         //.maximum	= 1,
        .step		= 1,
        .default_value = 0,
    },
	#endif
};

static int sensor_probe(struct i2c_client *client, const struct i2c_device_id *did);
static int sensor_video_probe(struct soc_camera_device *icd, struct i2c_client *client);
static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
static int sensor_g_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
static int sensor_s_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg);
static int sensor_resume(struct soc_camera_device *icd);
static int sensor_set_bus_param(struct soc_camera_device *icd,unsigned long flags);
static unsigned long sensor_query_bus_param(struct soc_camera_device *icd);
static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
static int sensor_deactivate(struct i2c_client *client);

static struct soc_camera_ops sensor_ops =
{
    .suspend                     = sensor_suspend,
    .resume                       = sensor_resume,
    .set_bus_param		= sensor_set_bus_param,
    .query_bus_param	= sensor_query_bus_param,
    .controls		= sensor_controls,
    .menus                         = sensor_menus,
    .num_controls		= ARRAY_SIZE(sensor_controls),
    .num_menus		= ARRAY_SIZE(sensor_menus),
};

/* only one fixed colorspace per pixelcode */
struct sensor_datafmt {
	enum v4l2_mbus_pixelcode code;
	enum v4l2_colorspace colorspace;
};

/* Find a data format by a pixel code in an array */
static const struct sensor_datafmt *sensor_find_datafmt(
	enum v4l2_mbus_pixelcode code, const struct sensor_datafmt *fmt,
	int n)
{
	int i;
	for (i = 0; i < n; i++)
		if (fmt[i].code == code)
			return fmt + i;

	return NULL;
}

static const struct sensor_datafmt sensor_colour_fmts[] = {
    {V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},
    {V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG}	
};


enum sensor_work_state
{
	sensor_work_ready = 0,
	sensor_working,
};
struct sensor_work
{
	struct i2c_client *client;
	struct delayed_work dwork;
	enum sensor_work_state state;
};

typedef struct sensor_info_priv_s
{
    int whiteBalance;
    int brightness;
    int contrast;
    int saturation;
    int effect;
    int scene;
    int digitalzoom;
    int focus;
	int auto_focus;
	int affm_reinit;
    int flash;
    int exposure;
    unsigned char mirror;                                        /* HFLIP */
    unsigned char flip;                                          /* VFLIP */
	bool snap2preview;
	bool video2preview;
	int capture_w;
	int capture_h;
	int preview_w;
	int preview_h;
    struct reginfo *winseqe_cur_addr;
	struct sensor_datafmt fmt;
	unsigned int enable;
	unsigned int funmodule_state;
} sensor_info_priv_t;



struct sensor_parameter
{
	unsigned short int preview_maxlines;
	unsigned short int preview_exposure;
	unsigned short int preview_line_width;
	unsigned short int preview_gain;

	unsigned short int capture_framerate;
	unsigned short int preview_framerate;
};

struct sensor
{
    struct v4l2_subdev subdev;
    struct i2c_client *client;
    sensor_info_priv_t info_priv;
	struct sensor_parameter parameter;
	struct workqueue_struct *sensor_wq;
	struct sensor_work sensor_wk;
	struct mutex wq_lock;
    int model;	/* V4L2_IDENT_OV* codes from v4l2-chip-ident.h */
#if CONFIG_SENSOR_I2C_NOSCHED
	atomic_t tasklock_cnt;
#endif
	struct rk29camera_platform_data *sensor_io_request;
    struct rk29camera_gpio_res *sensor_gpio_res;
};

static struct sensor* to_sensor(const struct i2c_client *client)
{
    return container_of(i2c_get_clientdata(client), struct sensor, subdev);
}

static int sensor_task_lock(struct i2c_client *client, int lock)
{
#if CONFIG_SENSOR_I2C_NOSCHED
	int cnt = 3;
    struct sensor *sensor = to_sensor(client);

	if (lock) {
		if (atomic_read(&sensor->tasklock_cnt) == 0) {
			while ((atomic_read(&client->adapter->bus_lock.count) < 1) && (cnt>0)) {
				SENSOR_TR("\n %s will obtain i2c in atomic, but i2c bus is locked! Wait...\n",SENSOR_NAME_STRING());
				msleep(35);
				cnt--;
			}
			if ((atomic_read(&client->adapter->bus_lock.count) < 1) && (cnt<=0)) {
				SENSOR_TR("\n %s obtain i2c fail in atomic!!\n",SENSOR_NAME_STRING());
				goto sensor_task_lock_err;
			}
			preempt_disable();
		}

		atomic_add(1, &sensor->tasklock_cnt);
	} else {
		if (atomic_read(&sensor->tasklock_cnt) > 0) {
			atomic_sub(1, &sensor->tasklock_cnt);

			if (atomic_read(&sensor->tasklock_cnt) == 0)
				preempt_enable();
		}
	}
    
	return 0;
sensor_task_lock_err:
	return -1;    
#else
    return 0;
#endif
}

/* sensor register write */

#if CONFIG_SENSOR_WRITE_REGS
static int sensor_write_regs(struct i2c_client *client,  u8 *reg_info, int num)
{
	int err=0,cnt;
	struct i2c_msg msg[1];

	msg->len = num;	
	msg->addr = client->addr;	
	msg->flags = client->flags;	
	msg->buf = reg_info;	
	msg->scl_rate = CONFIG_SENSOR_I2C_SPEED;         /* ddl@rock-chips.com : 100kHz */	
	msg->read_type = 0;               /* fpga i2c:0==I2C_NORMAL : direct use number not enum for don't want include spi_fpga.h */	

	
	cnt= 3;	
	err = -EAGAIN;
	
	while ((cnt-- > 0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */		
		err = i2c_transfer(client->adapter, msg, 1);		
		if (err >= 0) {		            
			return 0;		
		} else {		            
			SENSOR_TR("\n %s write reg failed, try to write again!\n",	SENSOR_NAME_STRING());		            
			udelay(10);	
		}	
	}
	
	return err;

}

#endif
#if 0
static int sensor_write(const struct i2c_client *client, struct reginfo *reg_info)
{
	struct i2c_msg msg;
	u8 buf[4];
	int ret;
       u16 command, data;
	command = reg_info->reg;
	data = reg_info->val;
	command = swab16(command);
	data = swab16(data);

	memcpy(buf + 0, &command, 2);
	memcpy(buf + 2, &data,    2);

	msg.addr  = client->addr;
	msg.flags = client->flags;
	msg.len   = 4;
	msg.buf   = buf;
	msg.scl_rate = CONFIG_SENSOR_I2C_SPEED;

	/*
	 * i2c_transfer return message length,
	 * but this function should return 0 if correct case
	 */
	ret = i2c_transfer(client->adapter, &msg, 1);
	if (ret >= 0)
		ret = 0;

	return ret;
}

static int sensor_read(const struct i2c_client *client, u16 command,u16 *val)
{
	struct i2c_msg msg[2];
	u8 buf[2];
	int ret;

	command = swab16(command);

	msg[0].addr  = client->addr;
	msg[0].flags = 0;
	msg[0].len   = 2;
	msg[0].buf   = (u8 *)&command;

	msg[1].addr  = client->addr;
	msg[1].flags = I2C_M_RD;
	msg[1].len   = 2;
	msg[1].buf   = buf;

	/*
	 * if return value of this function is < 0,
	 * it mean error.
	 * else, under 16bit is valid data.
	 */
	ret = i2c_transfer(client->adapter, msg, 2);
	if (ret < 0)
		return ret;

	memcpy(&ret, buf, 2);
	*val  = swab16(ret);
	return *val;
}

#else
static int sensor_write(struct i2c_client *client, struct reginfo *reg_info)
{
    int err=0,cnt;
    u8 buf[4];
    struct i2c_msg msg[1];

	switch (reg_info->reg)
	{
		case SEQUENCE_WAIT_MS:
		{
			if (in_atomic())
				mdelay(reg_info->val);
			else
				msleep(reg_info->val);
			break;
		}

		case SEQUENCE_WAIT_US:
		{
			udelay(reg_info->val);
			break;
		}

		case SEQUENCE_PROPERTY:
		{
			break;
		}
		default:
		{
		    buf[0] = reg_info->reg >> 8;
		    buf[1] = reg_info->reg & 0xFF;
			if (reg_info->reg_len == WORD_LEN) {
				buf[2] = reg_info->val >> 8;
				buf[3] = reg_info->val & 0xFF;

				msg->len = 4;
			} else if (reg_info->reg_len == BYTE_LEN) {
				buf[2] = reg_info->val;
				msg->len = 3;
			}

		    msg->addr = client->addr;
		    msg->flags = client->flags;
		    msg->buf = buf;
		    msg->scl_rate = CONFIG_SENSOR_I2C_SPEED;         /* ddl@rock-chips.com : 100kHz */
		    msg->read_type = 0;               /* fpga i2c:0==I2C_NORMAL : direct use number not enum for don't want include spi_fpga.h */
		    cnt = 3;
		    err = -EAGAIN;

		    while ((cnt-- > 0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */
		        err = i2c_transfer(client->adapter, msg, 1);

		        if (err >= 0) {
		            return 0;
		        } else {
		            udelay(10);
		        }
		    }
		}
	}
    return err;
}
static int sensor_write_16(struct i2c_client *client, u16 cmd,u16 val){
      struct reginfo reg_info;
      reg_info.reg = cmd;
      reg_info.val = val;
      sensor_write(client,&reg_info);
}
/* sensor register read */
static int sensor_read(struct i2c_client *client, u16 reg, u16 *val)
{
    int err,cnt;
    u8 buf[2];
    u16 temp_val;
    struct i2c_msg msg[2];

    buf[0] = reg >> 8;
    buf[1] = reg & 0xFF;

    msg[0].addr = client->addr;
    msg[0].flags = client->flags;
    msg[0].buf = buf;
    msg[0].len = sizeof(buf);
    msg[0].scl_rate = CONFIG_SENSOR_I2C_SPEED;       /* ddl@rock-chips.com : 100kHz */
    msg[0].read_type = 2;   /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */

    msg[1].addr = client->addr;
    msg[1].flags = client->flags|I2C_M_RD;
    msg[1].buf = buf;
    msg[1].len = 2;
    msg[1].scl_rate = CONFIG_SENSOR_I2C_SPEED;                       /* ddl@rock-chips.com : 100kHz */
    msg[1].read_type = 2;                             /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
//SENSOR_TR("Seven sensor read client->addr:%d\n",client->addr);
    cnt = 3;
    err = -EAGAIN;
    while ((cnt-- > 0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */
        err = i2c_transfer(client->adapter, msg, 2);

        if (err >= 0) {
		temp_val = buf[0];
		temp_val = temp_val << 8;
		temp_val = temp_val |buf[1];
            	*val = temp_val;
            return 0;
        } else {
            udelay(10);
        }
    }

    return err;
}
static u16 sensor_read_16(struct i2c_client *client, u16 reg){
	u16 value;
       sensor_read(client, reg, &value);
	return value;
}
#endif
/* write a array of registers  */
static int sensor_write_array(struct i2c_client *client, struct reginfo *regarray)
{
    int err = 0, cnt;
    int i = 0;
#if CONFIG_SENSOR_WRITE_REGS	
	int j = 0, reg_num;
	u8 *ptemp, *phead;
	int reg_length = 2;
#endif
//printk("%s,%d\n",__FUNCTION__,__LINE__);

#if CONFIG_SENSOR_I2C_RDWRCHK
	u16 valchk;
#endif

	cnt = 0;
	if (sensor_task_lock(client, 1) < 0)
		goto sensor_write_array_end;
    while (regarray[i].reg != SEQUENCE_END) {
#if CONFIG_SENSOR_WRITE_REGS
		j = i;		
		reg_num = 1;	
		
		if(WORD_LEN == regarray[i].reg_len) {
			reg_length = 0x0002;
		} else if (BYTE_LEN == regarray[i].reg_len) {
			reg_length = 0x0001;
		}
				
		while((regarray[i].reg + reg_length) == regarray[i+1].reg) {			
			i++;			
			reg_num++;		
		}
		
		if(reg_num > 1) {
			int size_num;
			
			if(0x0002 == reg_length) {
				size_num = 2*(reg_num + 1);
			} else {
				size_num = reg_num + 1;
			}
			
			ptemp = phead = (u8*)kmalloc(size_num*sizeof(u8),GFP_KERNEL);
            if (phead == NULL) {
				SENSOR_TR("%s write registers allocate memory fail!!!\n",SENSOR_NAME_STRING());
                i = j;
                err = sensor_write(client, &regarray[i]);                
			} else {			
    			*phead = regarray[j].reg >> 8;			
    			*(ptemp+1) = regarray[j].reg & 0xFF;		    	
    						
    			ptemp += 2;			
    					
    			if(0x0002 == reg_length) {
    				int temp = 0;	
    				for( ; reg_num > 0; reg_num --, j++, temp ++) {
    					*(ptemp + 2*temp) =  regarray[j].val >> 8;				
    					*(ptemp + 2*temp + 1) =  regarray[j].val & 0xFF;	
    				}
    			} else {
    				for( ; reg_num > 0; reg_num --, j++)
    				{
    					*ptemp ++ = regarray[j].val;
    				}
    			}
    			
    			ptemp = phead;
    			err = sensor_write_regs(client, ptemp,size_num);			
    			kfree(phead);	
			}
		} else {		
			err = sensor_write(client, &regarray[i]);	
		}
#else
		err = sensor_write(client, &regarray[i]);
#endif
        if (err < 0) {
            if (cnt-- > 0) {
			    SENSOR_TR("%s..write failed current reg:0x%x, Write array again !\n", SENSOR_NAME_STRING(),regarray[i].reg);
				i = 0;
				continue;
            } else {
                SENSOR_TR("%s..write array failed!!!\n", SENSOR_NAME_STRING());
                err = -EPERM;
				goto sensor_write_array_end;
            }
        } else {
        #if CONFIG_SENSOR_I2C_RDWRCHK
			sensor_read(client, regarray[i].reg, &valchk);
			//if (valchk != regarray[i].val)
				SENSOR_TR("%s num :%d ,Reg:0x%x write(0x%x, 0x%x) fail\n",SENSOR_NAME_STRING(), i,regarray[i].reg, regarray[i].val, valchk);
		#endif
        }

        i++;
    }

sensor_write_array_end:
	sensor_task_lock(client,0);
    return err;
}
#if CONFIG_SENSOR_I2C_RDWRCHK
static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regarray)
{
    int cnt;
    int i = 0;
	char valchk;

	cnt = 0;
	valchk = 0;
    while (regarray[i].reg != SEQUENCE_END)
    {
		sensor_read(client, regarray[i].reg, &valchk);
		if (valchk != regarray[i].val)
			SENSOR_TR("%s Reg:0x%x read(0x%x, 0x%x) error\n",SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);

        i++;
    }
    return 0;
}
#endif
#if CONFIG_SENSOR_Focus
static struct reginfo sensor_af_init0[] =
{
#if 0
{0x098E, 0x4403, WORD_LEN, 0 },// MCU_ADDRESS [AFM_ALGO]
{0x0990, 0x8008, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x8400, WORD_LEN, 0 },// MCU_ADDRESS [SEQ_CMD]

{SEQUENCE_WAIT_MS,10, WORD_LEN, 0},

{0x098E, 0x3003, WORD_LEN, 0 },// MCU_ADDRESS [AF_ALGO]
{0x0990, 0x0004, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x4406, WORD_LEN, 0 },// MCU_ADDRESS [AFM_POS_MIN]
{0x0990, 0x0010, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x4408, WORD_LEN, 0 },// MCU_ADDRESS [AFM_POS_MAX]
{0x0990, 0x00F0, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB021, WORD_LEN, 0 },// MCU_ADDRESS [AF_INIT_pos]
{0x0990, 0x0000, WORD_LEN, 0 },// MCU_DATA_0

{0x098E, 0xB00C, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_0]
{0x0990, 0x0000, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB00D, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_1]
{0x0990, 0x0010, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB00E, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_2]
{0x0990, 0x0020, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB00F, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_3]
{0x0990, 0x0030, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB010, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_4]
{0x0990, 0x0040, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB011, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_5]
{0x0990, 0x0050, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB012, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_6]
{0x0990, 0x0060, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB013, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_7]
{0x0990, 0x0080, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB014, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_8]
{0x0990, 0x00A0, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB015, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_6]
{0x0990, 0x00C0, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB016, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_7]
{0x0990, 0x00E0, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB017, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_8]
{0x0990, 0x00F0, WORD_LEN, 0 },// MCU_DATA_0

{0x098E, 0xB009, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_8]
{0x0990, 0x000C, WORD_LEN, 0 },// MCU_DATA_0

{0x098E, 0xB00B, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_8]
{0x0990, 0x0004, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB00A, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_8]
{0x0990, 0x0055, WORD_LEN, 0 },// MCU_DATA_0

{0x098E, 0xB002, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_8]
{0x0990, 0x0003, WORD_LEN, 0 },// MCU_DATA_0

#endif
#if 0
//[AF-continue scan for Qtech]
{0x098E, 0x4403, WORD_LEN, 0 },// MCU_ADDRESS [AFM_ALGO]
{0x0990, 0x8008, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x8400, WORD_LEN, 0 },// MCU_ADDRESS [SEQ_CMD]
{SEQUENCE_WAIT_MS,10, WORD_LEN, 0},
{0x098E, 0x3003, WORD_LEN, 0 },// MCU_ADDRESS [AF_ALGO]
{0x0990, 0x0010, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x4406, WORD_LEN, 0 },// MCU_ADDRESS [AFM_POS_MIN]
{0x0990, 0x0010, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x4408, WORD_LEN, 0 },// MCU_ADDRESS [AFM_POS_MAX]
{0x0990, 0x00F0, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB021, WORD_LEN, 0 },// MCU_ADDRESS [AF_INIT_pos]
{0x0990, 0x0000, WORD_LEN, 0 },// MCU_DATA_0


//[Optimize for Qtech]
{0x098E, 0xB00C, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_0]
{0x0990, 0x0000, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB00D, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_1]
{0x0990, 0x0010, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB00E, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_2]
{0x0990, 0x0020, WORD_LEN, 0 },// 0x0040
{0x098E, 0xB00F, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_3]
{0x0990, 0x0030, WORD_LEN, 0 },// 0x0060
{0x098E, 0xB010, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_4]
{0x0990, 0x0040, WORD_LEN, 0 },// 0x0080
{0x098E, 0xB011, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_5]
{0x0990, 0x0050, WORD_LEN, 0 },// 
{0x098E, 0xB012, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_6]
{0x0990, 0x0060, WORD_LEN, 0 },// 
{0x098E, 0xB013, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_7]
{0x0990, 0x0080, WORD_LEN, 0 },// 
{0x098E, 0xB014, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_8]
{0x0990, 0x00A0, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB015, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_9]
{0x0990, 0x00C0, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB016, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_10]
{0x0990, 0x00E0, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB017, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_11]
{0x0990, 0x00F0, WORD_LEN, 0 },// MCU_DATA_0

{0x098E, 0xB009, WORD_LEN, 0 },// MCU_ADDRESS [AF_NUM_STEPS]
{0x0990, 0x000C, WORD_LEN, 0 },// 12 steps


//[AF Second Scan]
{0x098E, 0xB00B, WORD_LEN, 0 },// AF_STEP_SIZE
{0x0990, 0x0004, WORD_LEN, 0 },// 
{0x098E, 0xB00A, WORD_LEN, 0 },// AF_NUM_STEP2
{0x0990, 0x0055, WORD_LEN, 0 },// 0x0005

//{0x098E, 0xB002, WORD_LEN, 0 },// AF_MODE
//{0x0990, 0x0003, WORD_LEN, 0 },// ??

//{0x098E, 0x8400, WORD_LEN, 0 },// 
//{0x0990, 0x0005, WORD_LEN, 0 },// 


//[AF_Weight and Range]
{0x098E, 0x304D, WORD_LEN, 0 },// MCU_ADDRESS [AF_ZONE_WEIGHTS_HI]
{0x0990, 0xEB82, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x304F, WORD_LEN, 0 },// MCU_ADDRESS [AF_ZONE_WEIGHTS_LO]
{0x0990, 0x82EB, WORD_LEN, 0 },// MCU_DATA_0

{0x098E, 0x3045, WORD_LEN, 0 },// MCU_ADDRESS [AF_W11X_START]
{0x0990, 0x0004, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x3047, WORD_LEN, 0 },// MCU_ADDRESS [AF_W11Y_START]
{0x0990, 0x0004, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x3049, WORD_LEN, 0 },// MCU_ADDRESS [AF_ZONE_WIDTH_VAR]
{0x0990, 0x0103, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x304B, WORD_LEN, 0 },// MCU_ADDRESS [AF_ZONE_HEIGHT_VAR]
{0x0990, 0x00C1, WORD_LEN, 0 },// MCU_DATA_0

#endif
#if 1
//[AF-Fullscan]
{0x098E, 0x4403, WORD_LEN, 0 },// MCU_ADDRESS [AFM_ALGO]
{0x0990, 0x8008, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x8400, WORD_LEN, 0 },// MCU_ADDRESS [SEQ_CMD]

{SEQUENCE_WAIT_MS,10, WORD_LEN, 0},

{0x098E, 0x3003, WORD_LEN, 0 },// MCU_ADDRESS [AF_ALGO]
{0x0990, 0x0004, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x4406, WORD_LEN, 0 },// MCU_ADDRESS [AFM_POS_MIN]
{0x0990, 0x0010, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0x4408, WORD_LEN, 0 },// MCU_ADDRESS [AFM_POS_MAX]
{0x0990, 0x00F0, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB021, WORD_LEN, 0 },// MCU_ADDRESS [AF_INIT_pos]
{0x0990, 0x0000, WORD_LEN, 0 },// MCU_DATA_0

{0x098E, 0xB00C, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_0]
{0x0990, 0x0000, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB00D, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_1]
{0x0990, 0x0010, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB00E, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_2]
{0x0990, 0x0020, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB00F, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_3]
{0x0990, 0x0030, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB010, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_4]
{0x0990, 0x0040, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB011, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_5]
{0x0990, 0x0050, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB012, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_6]
{0x0990, 0x0060, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB013, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_7]
{0x0990, 0x0080, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB014, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_8]
{0x0990, 0x00A0, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB015, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_9]
{0x0990, 0x00C0, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB016, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_10]
{0x0990, 0x00E0, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB017, WORD_LEN, 0 },// MCU_ADDRESS [AF_POSITIONS_11]
{0x0990, 0x00F0, WORD_LEN, 0 },// MCU_DATA_0

{0x098E, 0xB009, WORD_LEN, 0 },// MCU_ADDRESS AF_NUM_STEP
{0x0990, 0x000C, WORD_LEN, 0 },// MCU_DATA_0

{0x098E, 0xB00B, WORD_LEN, 0 },// MCU_ADDRESS [AF_STEP_SIZE]
{0x0990, 0x0004, WORD_LEN, 0 },// MCU_DATA_0
{0x098E, 0xB00A, WORD_LEN, 0 },// MCU_ADDRESS [AF_NUM_STEP2]
{0x0990, 0x0055, WORD_LEN, 0 },// MCU_DATA_0

{0x098E, 0xB002, WORD_LEN, 0 },// MCU_ADDRESS [AF_MODE]
//AF 2nd Scan disabled for quicker focus
// value 0x0003 : af 2nd scan on
// value 0x0001 : af 2nd scan off
{0x0990, 0x0003, WORD_LEN, 0 },// MCU_DATA_0
#endif
{SEQUENCE_WAIT_MS,20, WORD_LEN, 0},

{0x098E, 0x8400, WORD_LEN, 0 },// MCU_ADDRESS [SEQ_CMD]
{0x0990, 0x0005, WORD_LEN, 0 },// MCU_DATA_0
//delay=20
{SEQUENCE_WAIT_MS,20, WORD_LEN, 0},

{0x098E, 0x8400, WORD_LEN, 0 },// MCU_ADDRESS [SEQ_CMD]
{0x0990, 0x0006, WORD_LEN, 0 },// MCU_DATA_0
{SEQUENCE_WAIT_MS,20, WORD_LEN, 0},

//{SEQUENCE_WAIT_MS,400, WORD_LEN, 0},

{SEQUENCE_END, 0x00}
};


static struct reginfo sensor_af_trigger[] =
{
	{0x098E, 0xB008, WORD_LEN, 0 },// MCU_ADDRESS [SEQ_CMD]
	{0x0990, 0x0001, WORD_LEN, 0 },// MCU_DATA_0

	{SEQUENCE_END, 0x00}
};
static struct reginfo sensor_af_trigger_check[] =
{
	{0x098E, 0xB008, WORD_LEN, 0 },// MCU_ADDRESS [SEQ_CMD]

	{SEQUENCE_END, 0x00}
};

static int sensor_af_single(struct i2c_client *client)
{
	int ret = 0;
	int pid=0;
        SENSOR_DG("\n%s..%s..%d..\n",__FUNCTION__,__FILE__,__LINE__);
	//	printk("init af !!!\n");
	ret = sensor_write_array(client, sensor_af_trigger);
	if (ret<0)
	{
		SENSOR_TR("%s sensor auto focus trigger fail!!\n",SENSOR_NAME_STRING());
		goto sensor_af_single_end;
	}else{
		//printk("%s sensor auto focus trigger success!\n",SENSOR_NAME_STRING());
	}
			#if 1 //check sensor_af_trigger is ok!
		{
			{
				int temp=0;
				while(temp<60)
				{
					ret |= sensor_write_array(client, sensor_af_trigger_check);
					if (ret != 0) {
        					SENSOR_TR("%s sensor_Preview2Capture_check failed\n", SENSOR_NAME_STRING());
		   	 			goto sensor_af_single_end;
					}
					sensor_read(client, 0x0990, &pid);
					//pid=pid&0x1;
					//printk("%s,line=%d,pid=%d\n",__FUNCTION__,__LINE__,pid);
					if(pid==0)
					{
						break;
					}
					mdelay(20);
					temp++;
				}
					
			}
	
		}
		#endif

sensor_af_single_end:
	return ret;
}

static int sensor_af_const(struct i2c_client *client)
{
	int ret = 0;

//sensor_af_const_end:
	return ret;
}

static int sensor_af_zoneupdate(struct i2c_client *client)
{
	int ret = 0;

	return ret;
}

static int sensor_af_init(struct i2c_client *client)
{
	int ret = 0;
        SENSOR_DG("\n%s..%s..%d..\n",__FUNCTION__,__FILE__,__LINE__);
	//printk("\n%s..%s..%d..\n",__FUNCTION__,__FILE__,__LINE__);
	ret = sensor_write_array(client, sensor_af_init0);
	if (ret<0) {
		SENSOR_TR("%s sensor auto focus init_0 fail!!",SENSOR_NAME_STRING());
	}

	return ret;
}
#endif

static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
{
	struct soc_camera_link *icl = to_soc_camera_link(icd);
	int ret = 0;

    SENSOR_DG("%s %s  cmd(%d) on(%d)\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd,on);
	switch (cmd)
	{
		case Sensor_PowerDown:
		{
			if (icl->powerdown) {
				ret = icl->powerdown(icd->pdev, on);
				if (ret == RK29_CAM_IO_SUCCESS) {
					if (on == 0) {
						mdelay(2);
						if (icl->reset)
							icl->reset(icd->pdev);
					}
				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
					ret = -ENODEV;
					goto sensor_power_end;
				}
			}
			break;
		}
		case Sensor_Flash:
		{
			struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
    		struct sensor *sensor = to_sensor(client);

			if (sensor->sensor_io_request && sensor->sensor_io_request->sensor_ioctrl) {
				sensor->sensor_io_request->sensor_ioctrl(icd->pdev,Cam_Flash, on);
                if(on){
                    //flash off after 2 secs
            		hrtimer_cancel(&(flash_off_timer.timer));
            		hrtimer_start(&(flash_off_timer.timer),ktime_set(0, 800*1000*1000),HRTIMER_MODE_REL);
                    }
			}
			break;
		}
		case Sensor_Reset:
		{
		//printk("Sensor_Reset:%s,%d\n",__FUNCTION__,__LINE__);
			if (icl->reset) {
				ret = icl->reset(icd->pdev);
				/*
				if (ret == RK29_CAM_IO_SUCCESS) {
					if (on == 0) {
						mdelay(2);
						if (icl->reset)
							icl->reset(icd->pdev);
					}
				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
					ret = -ENODEV;
					goto sensor_power_end;
				}
				*/
			}
			break;
		}
		default:
		{
			SENSOR_TR("%s %s cmd(0x%x) is unknown!",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
			break;
		}
	}

sensor_power_end:
	return ret;
}


static enum hrtimer_restart flash_off_func(struct hrtimer *timer){
	struct flash_timer *fps_timer = container_of(timer, struct flash_timer, timer);
    sensor_ioctrl(fps_timer->icd,Sensor_Flash,0);
	SENSOR_DG("%s %s !!!!!!",SENSOR_NAME_STRING(),__FUNCTION__);
    return 0;
    
}

static int sensor_init(struct v4l2_subdev *sd, u32 val)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct soc_camera_device *icd = client->dev.platform_data;
    struct sensor *sensor = to_sensor(client);
	const struct v4l2_queryctrl *qctrl;
    const struct sensor_datafmt *fmt;
    int ret,pid = 0;
#if (SENSOR_RESET_REG != SEQUENCE_END)
    struct reginfo reg_info;
#endif
//	printk("sensor init start!\n");

	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
		ret = -ENODEV;
		goto sensor_INIT_ERR;
	}
	
	mdelay(100);
    ret = sensor_write_array(client, sensor_init_data);
    if (ret != 0)
    {
        //printk("Seven %s,%d\n",__FUNCTION__,__LINE__);
        SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
        goto sensor_INIT_ERR;
    }	
	sensor_task_lock(client,0);
	
    sensor->info_priv.preview_w = SENSOR_INIT_WIDTH;
    sensor->info_priv.preview_h = SENSOR_INIT_HEIGHT;
    sensor->info_priv.capture_w = SENSOR_MAX_WIDTH;
    sensor->info_priv.capture_h = SENSOR_MAX_HEIGHT;
	sensor->info_priv.winseqe_cur_addr  = SENSOR_INIT_WINSEQADR;
    fmt = sensor_find_datafmt(SENSOR_INIT_PIXFMT,sensor_colour_fmts, ARRAY_SIZE(sensor_colour_fmts));
    if (!fmt) {
        SENSOR_TR("error: %s initial array colour fmts is not support!!",SENSOR_NAME_STRING());
        ret = -EINVAL;
        goto sensor_INIT_ERR;
    }
	sensor->info_priv.fmt = *fmt;
    /* sensor sensor information for initialization  */
	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
	if (qctrl)
    	sensor->info_priv.whiteBalance = qctrl->default_value;
	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_BRIGHTNESS);
	if (qctrl)
    	sensor->info_priv.brightness = qctrl->default_value;
	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
	if (qctrl)
    	sensor->info_priv.effect = qctrl->default_value;
	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EXPOSURE);
	if (qctrl)
        sensor->info_priv.exposure = qctrl->default_value;

	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SATURATION);
	if (qctrl)
        sensor->info_priv.saturation = qctrl->default_value;
	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_CONTRAST);
	if (qctrl)
        sensor->info_priv.contrast = qctrl->default_value;
	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_HFLIP);
	if (qctrl)
        sensor->info_priv.mirror = qctrl->default_value;
	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_VFLIP);
	if (qctrl)
        sensor->info_priv.flip = qctrl->default_value;
	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SCENE);
	if (qctrl)
        sensor->info_priv.scene = qctrl->default_value;
	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
	if (qctrl)
        sensor->info_priv.digitalzoom = qctrl->default_value;

        sensor->info_priv.snap2preview = false;


    /* ddl@rock-chips.com : if sensor support auto focus and flash, programer must run focus and flash code  */
	//sensor_set_focus(); 
	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FOCUS_ABSOLUTE);
	if (qctrl)
        sensor->info_priv.focus = qctrl->default_value;
	#if CONFIG_SENSOR_Focus
	if (sensor_af_init(client) < 0) {
		sensor->info_priv.funmodule_state &= ~SENSOR_AF_IS_OK;
	} else {
		sensor->info_priv.funmodule_state |= SENSOR_AF_IS_OK;
	}
	//printk("%s,line=%d,sensor->info_priv.funmodule_state=%d\n",__FUNCTION__,__LINE__,sensor->info_priv.funmodule_state);
	#endif
	#if CONFIG_SENSOR_Flash
	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FLASH);
	if (qctrl)
	{
        	sensor->info_priv.flash = qctrl->default_value;
	}
    flash_off_timer.icd = icd;
	flash_off_timer.timer.function = flash_off_func;
    #endif
    SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),((val == 0)?__FUNCTION__:"sensor_reinit"),icd->user_width,icd->user_height);
 
// printk("sensor init end!\n");

    sensor->info_priv.funmodule_state |= SENSOR_INIT_IS_OK;
    return 0;
sensor_INIT_ERR:
    sensor->info_priv.funmodule_state &= ~SENSOR_INIT_IS_OK;
    SENSOR_DG("\n%s..%s..%d..\n",__FUNCTION__,__FILE__,__LINE__);
	sensor_task_lock(client,0);
	sensor_deactivate(client); 
    return ret;
}
static int sensor_deactivate(struct i2c_client *client)
{
	struct soc_camera_device *icd = client->dev.platform_data;
	u16 reg_val = 0;
    struct sensor *sensor = to_sensor(client);
    struct reginfo reg_info;
    
	SENSOR_DG("\n%s..%s.. Enter\n",SENSOR_NAME_STRING(),__FUNCTION__);
   // SENSOR_DG("\n%s..%s..%d..\n",__FUNCTION__,__FILE__,__LINE__);

	/* ddl@rock-chips.com : all sensor output pin must change to input for other sensor */
    if (sensor->info_priv.funmodule_state & SENSOR_INIT_IS_OK) {
    	sensor_task_lock(client, 1);
    	
    	sensor_read( client, 0x001a, &reg_val);
    	reg_info.reg = 0x001a;
    	reg_info.val = reg_val & (~0x0200);//reg_val & (~0x02);
    	reg_info.reg_len = 0x04;
    	sensor_write(client, &reg_info);
    	
    	sensor_task_lock(client, 0);
    }
	sensor_ioctrl(icd, Sensor_PowerDown, 1);
	/* ddl@rock-chips.com : sensor config init width , because next open sensor quickly(soc_camera_open -> Try to configure with default parameters) */
	icd->user_width = SENSOR_INIT_WIDTH;
    icd->user_height = SENSOR_INIT_HEIGHT;
	msleep(100);
    sensor->info_priv.funmodule_state &= ~SENSOR_INIT_IS_OK;
	return 0;
}
static  struct reginfo sensor_power_down_sequence[]=
{
    {0x00,0x00}
};
static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg)
{
    int ret;
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));

    if (pm_msg.event == PM_EVENT_SUSPEND) {
        SENSOR_DG("\n %s Enter Suspend.. \n", SENSOR_NAME_STRING());
        ret = sensor_write_array(client, sensor_power_down_sequence) ;
        if (ret != 0) {
            SENSOR_TR("\n %s..%s WriteReg Fail.. \n", SENSOR_NAME_STRING(),__FUNCTION__);
            return ret;
        } else {
            ret = sensor_ioctrl(icd, Sensor_PowerDown, 1);
            if (ret < 0) {
			    SENSOR_TR("\n %s suspend fail for turn on power!\n", SENSOR_NAME_STRING());
                return -EINVAL;
            }
        }
    } else {
        SENSOR_TR("\n %s cann't suppout Suspend..\n",SENSOR_NAME_STRING());
        return -EINVAL;
    }

    return 0;
}

static int sensor_resume(struct soc_camera_device *icd)
{
	int ret;

    ret = sensor_ioctrl(icd, Sensor_PowerDown, 0);
    if (ret < 0) {
		SENSOR_TR("\n %s resume fail for turn on power!\n", SENSOR_NAME_STRING());
        return -EINVAL;
    }

	SENSOR_DG("\n %s Enter Resume.. \n", SENSOR_NAME_STRING());
	return 0;
}

static int sensor_set_bus_param(struct soc_camera_device *icd,
                                unsigned long flags)
{

    return 0;
}

static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
{
    struct soc_camera_link *icl = to_soc_camera_link(icd);
    unsigned long flags = SENSOR_BUS_PARAM;

    return soc_camera_apply_sensor_flags(icl, flags);
}

static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct soc_camera_device *icd = client->dev.platform_data;
    struct sensor *sensor = to_sensor(client);

    mf->width	= icd->user_width;
	mf->height	= icd->user_height;
	mf->code	= sensor->info_priv.fmt.code;
	mf->colorspace	= sensor->info_priv.fmt.colorspace;
	mf->field	= V4L2_FIELD_NONE;

    return 0;
}
static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
{
    bool ret = false;

	if ((mf->width == 1024) && (mf->height == 768)) {
		ret = true;
	} else if ((mf->width == 1280) && (mf->height == 1024)) {
		ret = true;
	} else if ((mf->width == 1600) && (mf->height == 1200)) {
		ret = true;
	} else if ((mf->width == 2048) && (mf->height == 1536)) {
		ret = true;
	} else if ((mf->width == 2592) && (mf->height == 1944)) {
		ret = true;
	}

	if (ret == true)
		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, mf->width, mf->height);
	return ret;
}

static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
{
    bool ret = false;
    /*
	if ((mf->width == 1280) && (mf->height == 720)) {
		ret = true;
	} else if ((mf->width == 1920) && (mf->height == 1080)) {
		ret = true;
	}
    */
	if (ret == true)
		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, mf->width, mf->height);
	return ret;
}
static struct reginfo* sensor_fmt_catch(int set_w, int set_h, int *ret_w, int *ret_h)
{
	struct reginfo *winseqe_set_addr = NULL;

#if 0
    if (set_w*240 == set_h*320) {   
        if (((set_w <= 320) && (set_h <= 240)) && (sensor_qvga[0].reg!=SEQUENCE_END)) {
		//printk("enter sensor_qvga 320*240 \n ");
            winseqe_set_addr =sensor_qvga;
            *ret_w = 320;
            *ret_h = 240;
    	}  else  if (((set_w <= 640) && (set_h <= 480)) && (sensor_vga[0].reg!=SEQUENCE_END)) {
		//printk("enter sensor_vga 640*480 \n ");
            winseqe_set_addr = sensor_vga;
            *ret_w = 640;
            *ret_h = 480;
        } else if (((set_w <= 800) && (set_h <= 600)) && (sensor_svga[0].reg!=SEQUENCE_END)) {
		//printk("enter sensor_svga 800*600 \n ");
            winseqe_set_addr = sensor_svga;
            *ret_w = 800;
            *ret_h = 600;
        } else if (((set_w <= 1024) && (set_h <= 768)) && (sensor_xga[0].reg!=SEQUENCE_END)) {
		//printk("enter sensor_xga 1024*768 \n ");
            winseqe_set_addr = sensor_xga;
            *ret_w = 1024;
            *ret_h = 768;
    	} else  if (((set_w <= 1280) && (set_h <= 1024)) && (sensor_sxga[0].reg!=SEQUENCE_END)) {
		//printk("enter sensor_sxga 1280*1024 \n ");
            winseqe_set_addr = sensor_sxga;
            *ret_w = 1280;
            *ret_h = 1024;
        } else  if (((set_w <= 1600) && (set_h <= 1200)) && (sensor_uxga[0].reg!=SEQUENCE_END)) {
		//printk("enter sensor_uxga 1600*1200 \n ");
            winseqe_set_addr =  sensor_uxga;
            *ret_w = 1600;
            *ret_h = 1200;
    	} else if (((set_w <= 2048) && (set_h <= 1536)) && (sensor_qxga[0].reg!=SEQUENCE_END)) {
		//printk("enter sensor_qxga 2048*1536 \n ");
            winseqe_set_addr = sensor_qxga;
            *ret_w = 2048;
            *ret_h = 1536;
        } 

        if (winseqe_set_addr == NULL) {
            if (((set_w <= 176) && (set_h <= 144)) && (sensor_qcif[0].reg!=SEQUENCE_END)) {
        		winseqe_set_addr = sensor_qcif;
                *ret_w = 176;
                *ret_h = 144;
        	} else if (((set_w <= 352) && (set_h<= 288)) && (sensor_cif[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_cif;
                *ret_w = 352;
                *ret_h = 288;
            }else if (((set_w <= 640) && (set_h <= 480)) && (sensor_vga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_vga;
                *ret_w = 640;
                *ret_h = 480;
            } else if (((set_w <= 1280) && (set_h <= 720)) && (sensor_720p[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_720p;
                *ret_w = 1280;
                *ret_h = 720;
            } else if (((set_w <= 1920) && (set_h <= 1080)) && (sensor_1080p[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_1080p;
                *ret_w = 1920;
                *ret_h = 1080;
            } 
        }

    } else if (set_w*288 == set_h*352) {
        if (((set_w >= 176) && (set_h >= 144)) && (sensor_qcif[0].reg!=SEQUENCE_END)) {
    		winseqe_set_addr = sensor_qcif;
            *ret_w = 176;
            *ret_h = 144;
    	} 
	if (((set_w >= 352) && (set_h >= 288)) && (sensor_cif[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_cif;
            *ret_w = 352;
            *ret_h = 288;
        }

        if (winseqe_set_addr == NULL) {
            if (((set_w <= 320) && (set_h <= 240)) && (sensor_qvga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_qvga;
                *ret_w = 320;
                *ret_h = 240;
        	} else if (((set_w <= 640) && (set_h <= 480)) && (sensor_vga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_vga;
                *ret_w = 640;
                *ret_h = 480;
            } else if (((set_w <= 800) && (set_h <= 600)) && (sensor_svga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_svga;
                *ret_w = 800;
                *ret_h = 600;
            } else if (((set_w <= 1024) && (set_h <= 768)) && (sensor_xga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_xga;
                *ret_w = 1024;
                *ret_h = 768;
        	} else if (((set_w <= 1280) && (set_h <= 1024)) && (sensor_sxga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_sxga;
                *ret_w = 1280;
                *ret_h = 1024;
            } else if (((set_w <= 1600) && (set_h <= 1200)) && (sensor_uxga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_uxga;
                *ret_w = 1600;
                *ret_h = 1200;
        	} else if (((set_w <= 2048) && (set_h <= 1536)) && (sensor_qxga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_qxga;
                *ret_w = 2048;
                *ret_h = 1536;
            }else if (((set_w <= 1280) && (set_h <= 720)) && (sensor_720p[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_720p;
                *ret_w = 1280;
                *ret_h = 720;
            } else if (((set_w <= 1920) && (set_h <= 1080)) && (sensor_1080p[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_1080p;
                *ret_w = 1920;
                *ret_h = 1080;
            }  
        }
    } else if (set_w*720 == set_h*1280) {
        if (((set_w >= 1280) && (set_h >= 720)) && (sensor_720p[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_720p;
            *ret_w = 1280;
            *ret_h = 720;
        } else if (((set_w >= 1920) && (set_h >= 1080)) && (sensor_1080p[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_1080p;
            *ret_w = 1920;
            *ret_h = 1080;
        }

        if (winseqe_set_addr == NULL) {
    
            if (((set_w <= 176) && (set_h <= 144)) && (sensor_qcif[0].reg!=SEQUENCE_END)) {
        		winseqe_set_addr = sensor_qcif;
                *ret_w = 176;
                *ret_h = 144;
        	} else if (((set_w <= 352) && (set_h<= 288)) && (sensor_cif[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_cif;
                *ret_w = 352;
                *ret_h = 288;
            }
        
            if (((set_w <= 320) && (set_h <= 240)) && (sensor_qvga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_qvga;
                *ret_w = 320;
                *ret_h = 240;
        	} else if (((set_w <= 640) && (set_h <= 480)) && (sensor_vga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_vga;
                *ret_w = 640;
                *ret_h = 480;
            } else if (((set_w <= 800) && (set_h <= 600)) && (sensor_svga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_svga;
                *ret_w = 800;
                *ret_h = 600;
            } else if (((set_w <= 1024) && (set_h <= 768)) && (sensor_xga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_xga;
                *ret_w = 1024;
                *ret_h = 768;
        	} else if (((set_w <= 1280) && (set_h <= 1024)) && (sensor_sxga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_sxga;
                *ret_w = 1280;
                *ret_h = 1024;
            } else if (((set_w <= 1600) && (set_h <= 1200)) && (sensor_uxga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_uxga;
                *ret_w = 1600;
                *ret_h = 1200;
        	} else if (((set_w <= 2048) && (set_h <= 1536)) && (sensor_qxga[0].reg!=SEQUENCE_END)) {
                winseqe_set_addr = sensor_qxga;
                *ret_w = 2048;
                *ret_h = 1536;
            } 
        }
    } else {
        if (((set_w <= 176) && (set_h <= 144)) && (sensor_qcif[0].reg!=SEQUENCE_END)) {
    		winseqe_set_addr = sensor_qcif;
            *ret_w = 176;
            *ret_h = 144;
    	} else if (((set_w <= 320) && (set_h <= 240)) && (sensor_qvga[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_qvga;
            *ret_w = 320;
            *ret_h = 240;
    	} else if (((set_w <= 352) && (set_h<= 288)) && (sensor_cif[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_cif;
            *ret_w = 352;
            *ret_h = 288;
        } else if (((set_w <= 640) && (set_h <= 480)) && (sensor_vga[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_vga;
            *ret_w = 640;
            *ret_h = 480;
        } else if (((set_w <= 800) && (set_h <= 600)) && (sensor_svga[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_svga;
            *ret_w = 800;
            *ret_h = 600;
        } else if (((set_w <= 1024) && (set_h <= 768)) && (sensor_xga[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_xga;
            *ret_w = 1024;
            *ret_h = 768;
    	} else if (((set_w <= 1280) && (set_h <= 720)) && (sensor_720p[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_720p;
            *ret_w = 1280;
            *ret_h = 720;
        } else if (((set_w <= 1280) && (set_h <= 1024)) && (sensor_sxga[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_sxga;
            *ret_w = 1280;
            *ret_h = 1024;
        } else if (((set_w <= 1600) && (set_h <= 1200)) && (sensor_uxga[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_uxga;
            *ret_w = 1600;
            *ret_h = 1200;
    	} else if (((set_w <= 1920) && (set_h <= 1080)) && (sensor_1080p[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_1080p;
            *ret_w = 1920;
            *ret_h = 1080;
        } else if (((set_w <= 2048) && (set_h <= 1536)) && (sensor_qxga[0].reg!=SEQUENCE_END)) {
            winseqe_set_addr = sensor_qxga;
            *ret_w = 2048;
            *ret_h = 1536;
        }       
    }
	//FIX CTS
    *ret_w = *ret_w - 16;
    *ret_h = *ret_h - 16;
#else
    bool no_more_crop = false;
//crop w/h by percent, and align
#define FIX_WH(pw, ph, percent) { \
        int ratio = (((*pw) * percent)/100)&(~0x03); \
        *pw -= ratio; \
        *ph -= ((ratio*(*ph)/(*pw))+1)&(~0x01); \
    }
#define FIX_WH_PIXEL(pw, ph, pixel) { \
        *pw -= pixel; \
        *ph -= pixel; \
    }
#if 1
    if (!winseqe_set_addr && ((set_w <= 176) && (set_h <= 144))
            && (sensor_qcif[0].reg != SEQUENCE_END)) {
        winseqe_set_addr = sensor_qcif;
        *ret_w = 176;
        *ret_h = 144;
    }
    FIX_WH(ret_w, ret_h, 3);//crop for fov
#else
    //use 352x288 + ipp -> 176x144 for fov
    if (!winseqe_set_addr && ((set_w <= 176) && (set_h <= 144))
            && sensor_cif[0].reg != SEQUENCE_END) {
        winseqe_set_addr = sensor_cif;
        *ret_w = 352;
        *ret_h = 288;
    }
#endif
    if (!winseqe_set_addr && ((set_w <= 320) && (set_h <= 240))
            && sensor_qvga[0].reg != SEQUENCE_END) {
        winseqe_set_addr = sensor_qvga;
        *ret_w = 320;
        *ret_h = 240;
    }
    if (!winseqe_set_addr && ((set_w <= 352) && (set_h <= 288))
            && sensor_cif[0].reg != SEQUENCE_END) {
        winseqe_set_addr = sensor_cif;
        *ret_w = 352;
        *ret_h = 288;
    }
    FIX_WH(ret_w, ret_h, 2);//crop for fov
    if (!winseqe_set_addr && ((set_w <= 640) && (set_h <= 480))
            && sensor_vga[0].reg != SEQUENCE_END) {
        winseqe_set_addr = sensor_vga;
        *ret_w = 640;
        *ret_h = 480;
    }
    FIX_WH(ret_w, ret_h, 1);//crop for fov
    if (!winseqe_set_addr && ((set_w <= 720) && (set_h <= 480))
            && sensor_uxga[0].reg != SEQUENCE_END) {
        //dont have 720x480, just fake it, and work fine.
        winseqe_set_addr = sensor_uxga;
        *ret_w = 1600;
        *ret_h = 1200;
    }
#if 1
    if (!winseqe_set_addr && ((set_w <= 800) && (set_h <= 600))
            && sensor_svga[0].reg != SEQUENCE_END) {
        winseqe_set_addr = sensor_svga;
        *ret_w = 800;
        *ret_h = 600;
	// Cause ghost effect on preview
        FIX_WH_PIXEL(ret_w, ret_h, 16);//crop for preview speed
        no_more_crop = true;
    }
#else
//use 1280x720 + ipp -> 800x600 for preview & auto focus
    if (!winseqe_set_addr && ((set_w <= 800) && (set_h <= 600))
            && sensor_720p[0].reg != SEQUENCE_END) {
        winseqe_set_addr = sensor_720p;
        *ret_w = 1280;
        *ret_h = 720;
    }
#endif
    if (!winseqe_set_addr && ((set_w <= 1024) && (set_h <= 768))
            && sensor_xga[0].reg != SEQUENCE_END) {
        winseqe_set_addr = sensor_xga;
        *ret_w = 1024;
        *ret_h = 768;
    }
    if (!winseqe_set_addr && ((set_w <= 1280) && (set_h <= 720))
            && sensor_720p[0].reg != SEQUENCE_END) {
        winseqe_set_addr = sensor_720p;
        *ret_w = 1280;
        *ret_h = 720;
        FIX_WH_PIXEL(ret_w, ret_h, 16);//crop for preview speed
        no_more_crop = true;
    }
    if (!winseqe_set_addr && ((set_w <= 1600) && (set_h <= 1200))
            && sensor_uxga[0].reg != SEQUENCE_END) {
        winseqe_set_addr = sensor_uxga;
        *ret_w = 1600;
        *ret_h = 1200;
    }
    if (!winseqe_set_addr //&& ((set_w <= 2048) && (set_h <= 1536)) //max level
            && sensor_qxga[0].reg != SEQUENCE_END) {
        winseqe_set_addr = sensor_qxga;
        *ret_w = 2048;
        *ret_h = 1536;
    }
    if(!no_more_crop){
    	FIX_WH(ret_w, ret_h, 1);//crop for preview speed
    }
#endif

    return winseqe_set_addr;
}

static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    const struct sensor_datafmt *fmt;
    struct soc_camera_device *icd = client->dev.platform_data;
    struct sensor *sensor = to_sensor(client);
    struct reginfo *winseqe_set_addr=NULL;
    int ret = 0, set_w,set_h;
    //u16 seq_state=0;
	int pid = 0;
    fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
				   ARRAY_SIZE(sensor_colour_fmts));
	if (!fmt) {
        ret = -EINVAL;
        goto sensor_s_fmt_end;
    }

	if (sensor->info_priv.fmt.code != mf->code) {
		switch (mf->code)
		{
			case V4L2_MBUS_FMT_YUYV8_2X8:
			{
				winseqe_set_addr = sensor_ClrFmt_YUYV;
				break;
			}
			case V4L2_MBUS_FMT_UYVY8_2X8:
			{
				winseqe_set_addr = sensor_ClrFmt_UYVY;
				break;
			}
			default:
				break;
		}
		if (winseqe_set_addr != NULL) {
            sensor_write_array(client, winseqe_set_addr);
			sensor->info_priv.fmt.code = mf->code;
            sensor->info_priv.fmt.colorspace= mf->colorspace;            
			SENSOR_DG("%s v4l2_mbus_code:%d set success!\n", SENSOR_NAME_STRING(),mf->code);
		} else {
			SENSOR_TR("%s v4l2_mbus_code:%d is invalidate!\n", SENSOR_NAME_STRING(),mf->code);
		}
	}

    set_w = mf->width;
    set_h = mf->height;
	
	winseqe_set_addr = sensor_fmt_catch(set_w, set_h, &set_w, &set_h);
	//printk("%s,%d,set_w:%d,set_h:%d\n",__FUNCTION__,__LINE__,set_w,set_h);
    if ((winseqe_set_addr  != sensor->info_priv.winseqe_cur_addr) && winseqe_set_addr) {
        ret |= sensor_write_array(client, winseqe_set_addr);
        if (ret != 0) {
            SENSOR_TR("%s set format capability failed\n", SENSOR_NAME_STRING());
            goto sensor_s_fmt_end;
        }
		
        sensor->info_priv.winseqe_cur_addr  = winseqe_set_addr;
		if ((winseqe_set_addr[0].reg==SEQUENCE_PROPERTY) && (winseqe_set_addr[0].val==SEQUENCE_CAPTURE)) {

        } else {
			sensor->info_priv.preview_w = mf->width;
			sensor->info_priv.preview_h = mf->height;
		}
    }
    	//printk("%s,%d,preview_w:%d,preview_h:%d,mf->width:%d,mf->height:%d\n",__FUNCTION__,__LINE__,sensor->info_priv.preview_w,sensor->info_priv.preview_h,mf->width,mf->height);
	if (winseqe_set_addr && (winseqe_set_addr[0].reg==SEQUENCE_PROPERTY) && (winseqe_set_addr[0].val==SEQUENCE_CAPTURE)) {

	/*#if CONFIG_SENSOR_Flash
        	if( (sensor->info_priv.flash == 1)|| (sensor->info_priv.flash == 2)) {
           		sensor_ioctrl(icd, Sensor_Flash, Flash_On);
			 //sensor_ioctrl(icd, Sensor_Flash, Flash_Torch);
        	}
        #endif   */
		

		ret |= sensor_write_array(client, sensor_Preview2Capture);
		if (ret != 0) {
        	SENSOR_TR("%s Preview 2 Capture failed\n", SENSOR_NAME_STRING());
		    goto sensor_s_fmt_end;
		}

		#if 1 //check preview2Capture is ok!
		{
			{
				int temp=0;
				while(temp<60)
				{
					ret |= sensor_write_array(client, sensor_Preview2Capture_check);
					if (ret != 0) {
        					SENSOR_TR("%s sensor_Preview2Capture_check failed\n", SENSOR_NAME_STRING());
		   	 			goto sensor_s_fmt_end;
					}
					sensor_read(client, 0x990, &pid);
					//printk("%s,line=%d,pid=%d\n",__FUNCTION__,__LINE__,pid);
					if(pid==7)
					{
						break;
					}
					mdelay(20);
					temp++;
					if ((temp % 10) == 0) {
						ret |= sensor_write_array(client, sensor_Preview2Capture);
						if (ret != 0) {
				        	SENSOR_TR("%s Preview 2 Capture failed\n", SENSOR_NAME_STRING());
						    goto sensor_s_fmt_end;
						}
					}
				}
					
			}
		}
		#endif
        SENSOR_DG("%s Preview 2 Capture success!\n", SENSOR_NAME_STRING());
	    // mdelay(200);  
        #if 0//CONFIG_SENSOR_Flash
        if( (sensor->info_priv.flash == 1)|| (sensor->info_priv.flash == 2)) {
           sensor_ioctrl(icd, Sensor_Flash, Flash_On);
			 //sensor_ioctrl(icd, Sensor_Flash, Flash_Torch);
            //SENSOR_DG("----flash-------%s    sensor->info_priv.flash = %d ,flash on in capture!\n", SENSOR_NAME_STRING(),sensor->info_priv.flash);
        }
        #endif 
       
		sensor->info_priv.capture_w = set_w;
		sensor->info_priv.capture_h = set_h;
		sensor->info_priv.snap2preview = true;
	} else if (sensor->info_priv.snap2preview == true) {
		if (winseqe_set_addr || ((sensor->info_priv.preview_w == mf->width) && (sensor->info_priv.preview_h == mf->height))) {
			#if 0 //CONFIG_SENSOR_Flash
            if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
                sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
            }
            #endif    
			ret |= sensor_write_array(client, sensor_Capture2Preview);
			if (ret != 0) {
	        	SENSOR_TR("%s Capture 2 Preview failed !!\n", SENSOR_NAME_STRING());
	        	goto sensor_s_fmt_end;
	    	}
            		#if 1 //check preview2Capture is ok!
		{
			{
				int temp=0;
				while(temp<60)
				{
					ret |= sensor_write_array(client, sensor_Preview2Capture_check);
					if (ret != 0) {
        					SENSOR_TR("%s sensor_Preview2Capture_check failed\n", SENSOR_NAME_STRING());
		   	 			goto sensor_s_fmt_end;
					}
					sensor_read(client, 0x990, &pid);
					//printk("%s,line=%d,pid=%d\n",__FUNCTION__,__LINE__,pid);
					if(pid==3)
					{
						break;
					}
					mdelay(20);
					temp++;
				}
					
			}
					/*
			    ret = sensor_read(client, 0x8401, &pid);
    				if (ret != 0) {
        				SENSOR_TR("read chip id failed\n");
        				ret = -ENODEV;
        				goto sensor_s_fmt_end;
    				}
			*/
			//printk("ttian printf 0x8401 register = %d \n",pid);		
		}
		#endif

	        mdelay(20);  //delay  microseconds to forbid invalidate data
			
            SENSOR_DG("%s Capture 2 Preview success\n", SENSOR_NAME_STRING());
           /* #if CONFIG_SENSOR_Flash
            if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
                sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
            }
            #endif     */   
    		sensor->info_priv.preview_w = mf->width;
    		sensor->info_priv.preview_h = mf->height;
    		sensor->info_priv.snap2preview = false;
		} else {
			SENSOR_TR("\n %s..%s Format is Invalidate. mf->width = %d.. mf->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,mf->width,mf->height);
		}
	}

	mf->width = set_w;
	mf->height = set_h;
sensor_s_fmt_end:
    return ret;
}

static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct sensor *sensor = to_sensor(client);
    const struct sensor_datafmt *fmt;
    int ret = 0;
   
	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
				   ARRAY_SIZE(sensor_colour_fmts));
	if (fmt == NULL) {
		fmt = &sensor->info_priv.fmt;
        mf->code = fmt->code;
	} 
	//printk("%s line=%d,mf->width=%d,mf->height=%d\n",__FUNCTION__,__LINE__,mf->width,mf->height);

    if (mf->height > SENSOR_MAX_HEIGHT)
        mf->height = SENSOR_MAX_HEIGHT;
    else if (mf->height < SENSOR_MIN_HEIGHT)
        mf->height = SENSOR_MIN_HEIGHT;

    if (mf->width > SENSOR_MAX_WIDTH)
        mf->width = SENSOR_MAX_WIDTH;
    else if (mf->width < SENSOR_MIN_WIDTH)
        mf->width = SENSOR_MIN_WIDTH;
    mf->colorspace = fmt->colorspace;
	//printk("%s line=%d,mf->width=%d,mf->height=%d\n",__FUNCTION__,__LINE__,mf->width,mf->height);
	if (sensor_fmt_catch(mf->width, mf->height, &mf->width, &mf->height) == NULL) {
		mf->width = 0;
		mf->height = 0;
	}
	//printk("%s line=%d,mf->width=%d,mf->height=%d\n",__FUNCTION__,__LINE__,mf->width,mf->height);

    return ret;
}

 static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);

    if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
        return -EINVAL;

    if (id->match.addr != client->addr)
        return -ENODEV;

    id->ident = SENSOR_V4L2_IDENT;      /* ddl@rock-chips.com :  Return OV2655  identifier */
    id->revision = 0;

    return 0;
}
#if CONFIG_SENSOR_Brightness
static int sensor_set_brightness(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));

    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
    {
        if (sensor_BrightnessSeqe[value - qctrl->minimum] != NULL)
        {
            if (sensor_write_array(client, sensor_BrightnessSeqe[value - qctrl->minimum]) != 0)
            {
                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
                return -EINVAL;
            }
            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
            return 0;
        }
    }
	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
    return -EINVAL;
}
#endif
#if CONFIG_SENSOR_Effect
static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));

    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
    {
        if (sensor_EffectSeqe[value - qctrl->minimum] != NULL)
        {
            if (sensor_write_array(client, sensor_EffectSeqe[value - qctrl->minimum]) != 0)
            {
                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
                return -EINVAL;
            }
            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
            return 0;
        }
    }
	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
    return -EINVAL;
}
#endif
#if CONFIG_SENSOR_Exposure
static int sensor_set_exposure(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));

    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
    {
        if (sensor_ExposureSeqe[value - qctrl->minimum] != NULL)
        {
            if (sensor_write_array(client, sensor_ExposureSeqe[value - qctrl->minimum]) != 0)
            {
                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
                return -EINVAL;
            }
           // printk("%s..%s : %x   minimum: %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value,qctrl->minimum);
            return 0;
        }
    }
	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
    return -EINVAL;
}
#endif
#if CONFIG_SENSOR_Saturation
static int sensor_set_saturation(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));

    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
    {
        if (sensor_SaturationSeqe[value - qctrl->minimum] != NULL)
        {
            if (sensor_write_array(client, sensor_SaturationSeqe[value - qctrl->minimum]) != 0)
            {
                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
                return -EINVAL;
            }
            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
            return 0;
        }
    }
    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
    return -EINVAL;
}
#endif
#if CONFIG_SENSOR_Contrast
static int sensor_set_contrast(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));

    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
    {
        if (sensor_ContrastSeqe[value - qctrl->minimum] != NULL)
        {
            if (sensor_write_array(client, sensor_ContrastSeqe[value - qctrl->minimum]) != 0)
            {
                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
                return -EINVAL;
            }
            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
            return 0;
        }
    }
    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
    return -EINVAL;
}
#endif
#if CONFIG_SENSOR_Mirror
static int sensor_set_mirror(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));

    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
    {
        if (sensor_MirrorSeqe[value - qctrl->minimum] != NULL)
        {
            if (sensor_write_array(client, sensor_MirrorSeqe[value - qctrl->minimum]) != 0)
            {
                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
                return -EINVAL;
            }
            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
            return 0;
        }
    }
    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
    return -EINVAL;
}
#endif
#if CONFIG_SENSOR_Flip
static int sensor_set_flip(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));

    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
    {
        if (sensor_FlipSeqe[value - qctrl->minimum] != NULL)
        {
            if (sensor_write_array(client, sensor_FlipSeqe[value - qctrl->minimum]) != 0)
            {
                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
                return -EINVAL;
            }
            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
            return 0;
        }
    }
    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
    return -EINVAL;
}
#endif
#if CONFIG_SENSOR_Scene
static int sensor_set_scene(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));

    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
    {
        if (sensor_SceneSeqe[value - qctrl->minimum] != NULL)
        {
            if (sensor_write_array(client, sensor_SceneSeqe[value - qctrl->minimum]) != 0)
            {
                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
                return -EINVAL;
            }
            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
            return 0;
        }
    }
    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
    return -EINVAL;
}
#endif
#if CONFIG_SENSOR_WhiteBalance
static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));

    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
    {
        if (sensor_WhiteBalanceSeqe[value - qctrl->minimum] != NULL)
        {
            if (sensor_write_array(client, sensor_WhiteBalanceSeqe[value - qctrl->minimum]) != 0)
            {
                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
                return -EINVAL;
            }
            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
            return 0;
        }
    }
	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
    return -EINVAL;
}
#endif
#if CONFIG_SENSOR_DigitalZoom
static int sensor_set_digitalzoom(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int *value)
{
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
    struct sensor *sensor = to_sensor(client);
	const struct v4l2_queryctrl *qctrl_info;
    int digitalzoom_cur, digitalzoom_total;

	qctrl_info = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
	if (qctrl_info)
		return -EINVAL;

    digitalzoom_cur = sensor->info_priv.digitalzoom;
    digitalzoom_total = qctrl_info->maximum;

    if ((*value > 0) && (digitalzoom_cur >= digitalzoom_total))
    {
        SENSOR_TR("%s digitalzoom is maximum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
        return -EINVAL;
    }

    if  ((*value < 0) && (digitalzoom_cur <= qctrl_info->minimum))
    {
        SENSOR_TR("%s digitalzoom is minimum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
        return -EINVAL;
    }

    if ((*value > 0) && ((digitalzoom_cur + *value) > digitalzoom_total))
    {
        *value = digitalzoom_total - digitalzoom_cur;
    }

    if ((*value < 0) && ((digitalzoom_cur + *value) < 0))
    {
        *value = 0 - digitalzoom_cur;
    }

    digitalzoom_cur += *value;

    if (sensor_ZoomSeqe[digitalzoom_cur] != NULL)
    {
        if (sensor_write_array(client, sensor_ZoomSeqe[digitalzoom_cur]) != 0)
        {
            SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
            return -EINVAL;
        }
        SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, *value);
        return 0;
    }

    return -EINVAL;
}
#endif
#if CONFIG_SENSOR_Flash
static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{	
    if ((value >= qctrl->minimum) && (value <= qctrl->maximum)) {
        if (value == 3) {       /* ddl@rock-chips.com: torch */
            sensor_ioctrl(icd, Sensor_Flash, Flash_Torch);   /* Flash On */
        } else {
            sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
        }
        SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
        return 0;
    }
    
	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
    return -EINVAL;
}
#endif
#if CONFIG_SENSOR_Focus
static int sensor_set_focus_absolute(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{
	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
    struct sensor *sensor = to_sensor(client);
	const struct v4l2_queryctrl *qctrl_info;
	int ret = 0;

	qctrl_info = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FOCUS_ABSOLUTE);
	if (!qctrl_info)
	{
		return -EINVAL;
	}
	if ((sensor->info_priv.funmodule_state & SENSOR_AF_IS_OK) && (sensor->info_priv.affm_reinit == 0)) {
		if ((value >= qctrl_info->minimum) && (value <= qctrl_info->maximum)) {

			SENSOR_DG("%s..%s : %d  ret:0x%x\n",SENSOR_NAME_STRING(),__FUNCTION__, value,ret);
		} else {
			ret = -EINVAL;
			SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
			goto sensor_set_focus_absolute_end;
		}
	} else {
		ret = -EACCES;
		SENSOR_TR("\n %s..%s AF module state(0x%x, 0x%x) is error!\n",SENSOR_NAME_STRING(),__FUNCTION__,
			sensor->info_priv.funmodule_state,sensor->info_priv.affm_reinit);
	}

sensor_set_focus_absolute_end:
	return ret;
}
static int sensor_set_focus_relative(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{
	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
	struct sensor *sensor = to_sensor(client);
	const struct v4l2_queryctrl *qctrl_info;
	int ret = 0;

	qctrl_info = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FOCUS_RELATIVE);
	if (!qctrl_info)
	{
		ret = -EINVAL;
		goto sensor_set_focus_relative_end;
		//return -EINVAL;
	}
	if ((sensor->info_priv.funmodule_state & SENSOR_AF_IS_OK) && (sensor->info_priv.affm_reinit == 0)) {
		if ((value >= qctrl_info->minimum) && (value <= qctrl_info->maximum)) {

			SENSOR_DG("%s..%s : %d  ret:0x%x\n",SENSOR_NAME_STRING(),__FUNCTION__, value,ret);
		} else {
			ret = -EINVAL;
			SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
		}
	} else {
		ret = -EACCES;
		SENSOR_TR("\n %s..%s AF module state(0x%x, 0x%x) is error!\n",SENSOR_NAME_STRING(),__FUNCTION__,
			sensor->info_priv.funmodule_state,sensor->info_priv.affm_reinit);
	}
sensor_set_focus_relative_end:
	return ret;
}

static int sensor_set_focus_mode(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
{
	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
	struct sensor *sensor = to_sensor(client);
	int ret = 0;
	if ((sensor->info_priv.funmodule_state & SENSOR_AF_IS_OK)  && (sensor->info_priv.affm_reinit == 0)) {
		switch (value)
		{
			case SENSOR_AF_MODE_AUTO:
			{
				ret = sensor_af_single(client);
				break;
			}

			case SENSOR_AF_MODE_MACRO:
			{
				ret = sensor_set_focus_absolute(icd, qctrl, 0xff);
				break;
			}

			case SENSOR_AF_MODE_INFINITY:
			{
				ret = sensor_set_focus_absolute(icd, qctrl, 0x00);
				break;
			}

			case SENSOR_AF_MODE_CONTINUOUS:
			{
				ret = sensor_af_const(client);
				break;
			}
			default:
				SENSOR_TR("\n %s..%s AF value(0x%x) is error!\n",SENSOR_NAME_STRING(),__FUNCTION__,value);
				break;

		}

		SENSOR_DG("%s..%s : %d  ret:0x%x\n",SENSOR_NAME_STRING(),__FUNCTION__, value,ret);
	} else {
		ret = -EACCES;
		SENSOR_TR("\n %s..%s AF module state(0x%x, 0x%x) is error!\n",SENSOR_NAME_STRING(),__FUNCTION__,
			sensor->info_priv.funmodule_state,sensor->info_priv.affm_reinit);
	}

	return ret;
}
#endif
static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct sensor *sensor = to_sensor(client);
    const struct v4l2_queryctrl *qctrl;
    SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());

    qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);

    if (!qctrl)
    {
        SENSOR_TR("\n %s ioctrl id = 0x%x  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
        return -EINVAL;
    }

    switch (ctrl->id)
    {
        case V4L2_CID_BRIGHTNESS:
            {
                ctrl->value = sensor->info_priv.brightness;
                break;
            }
        case V4L2_CID_SATURATION:
            {
                ctrl->value = sensor->info_priv.saturation;
                break;
            }
        case V4L2_CID_CONTRAST:
            {
                ctrl->value = sensor->info_priv.contrast;
                break;
            }
        case V4L2_CID_DO_WHITE_BALANCE:
            {
                ctrl->value = sensor->info_priv.whiteBalance;
                break;
            }
        case V4L2_CID_EXPOSURE:
            {
                ctrl->value = sensor->info_priv.exposure;
                break;
            }
        case V4L2_CID_HFLIP:
            {
                ctrl->value = sensor->info_priv.mirror;
                break;
            }
        case V4L2_CID_VFLIP:
            {
                ctrl->value = sensor->info_priv.flip;
                break;
            }
        default :
                break;
    }
    return 0;
}



static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct sensor *sensor = to_sensor(client);
    struct soc_camera_device *icd = client->dev.platform_data;
    const struct v4l2_queryctrl *qctrl;
    SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());


    qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);

    if (!qctrl)
    {
        SENSOR_TR("\n %s ioctrl id = 0x%x  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
        return -EINVAL;
    }
	//printk("%s, sensor->info_priv.exposure=%d,ctrl->value=%d,ctrl->id=%d\n",__FUNCTION__, sensor->info_priv.exposure,ctrl->value,ctrl->id);
    switch (ctrl->id)
    {
#if CONFIG_SENSOR_Brightness
        case V4L2_CID_BRIGHTNESS:
            {
                if (ctrl->value != sensor->info_priv.brightness)
                {
                    if (sensor_set_brightness(icd, qctrl,ctrl->value) != 0)
                    {
                        return -EINVAL;
                    }
                    sensor->info_priv.brightness = ctrl->value;
                }
                break;
            }
#endif
#if CONFIG_SENSOR_Exposure
        case V4L2_CID_EXPOSURE:
            {
		//printk("%s, sensor->info_priv.exposure=%d,ctrl->value=%d\n",__FUNCTION__, sensor->info_priv.exposure,ctrl->value);
                if (ctrl->value != sensor->info_priv.exposure)
                {
                    if (sensor_set_exposure(icd, qctrl,ctrl->value) != 0)
                    {
                        return -EINVAL;
                    }
                    sensor->info_priv.exposure = ctrl->value;
                }
                break;
            }
#endif
#if CONFIG_SENSOR_Saturation
        case V4L2_CID_SATURATION:
            {
                if (ctrl->value != sensor->info_priv.saturation)
                {
                    if (sensor_set_saturation(icd, qctrl,ctrl->value) != 0)
                    {
                        return -EINVAL;
                    }
                    sensor->info_priv.saturation = ctrl->value;
                }
                break;
            }
#endif
#if CONFIG_SENSOR_Contrast
        case V4L2_CID_CONTRAST:
            {
                if (ctrl->value != sensor->info_priv.contrast)
                {
                    if (sensor_set_contrast(icd, qctrl,ctrl->value) != 0)
                    {
                        return -EINVAL;
                    }
                    sensor->info_priv.contrast = ctrl->value;
                }
                break;
            }
#endif
#if CONFIG_SENSOR_WhiteBalance
        case V4L2_CID_DO_WHITE_BALANCE:
            {
                if (ctrl->value != sensor->info_priv.whiteBalance)
                {
                    if (sensor_set_whiteBalance(icd, qctrl,ctrl->value) != 0)
                    {
                        return -EINVAL;
                    }
                    sensor->info_priv.whiteBalance = ctrl->value;
                }
                break;
            }
#endif
#if CONFIG_SENSOR_Mirror
        case V4L2_CID_HFLIP:
            {
                if (ctrl->value != sensor->info_priv.mirror)
                {
                    if (sensor_set_mirror(icd, qctrl,ctrl->value) != 0)
                        return -EINVAL;
                    sensor->info_priv.mirror = ctrl->value;
                }
                break;
            }
#endif
#if CONFIG_SENSOR_Flip
        case V4L2_CID_VFLIP:
            {
                if (ctrl->value != sensor->info_priv.flip)
                {
                    if (sensor_set_flip(icd, qctrl,ctrl->value) != 0)
                        return -EINVAL;
                    sensor->info_priv.flip = ctrl->value;
                }
                break;
            }
#endif
        default:
            break;
    }

    return 0;
}
static int sensor_g_ext_control(struct soc_camera_device *icd , struct v4l2_ext_control *ext_ctrl)
{
    const struct v4l2_queryctrl *qctrl;
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
    struct sensor *sensor = to_sensor(client);
    SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());

    qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);

    if (!qctrl)
    {
        SENSOR_TR("\n %s ioctrl id = 0x%x  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
        return -EINVAL;
    }

    switch (ext_ctrl->id)
    {
        case V4L2_CID_SCENE:
            {
                ext_ctrl->value = sensor->info_priv.scene;
                break;
            }
        case V4L2_CID_EFFECT:
            {
                ext_ctrl->value = sensor->info_priv.effect;
                break;
            }
        case V4L2_CID_ZOOM_ABSOLUTE:
            {
                ext_ctrl->value = sensor->info_priv.digitalzoom;
                break;
            }
        case V4L2_CID_ZOOM_RELATIVE:
            {
                return -EINVAL;
            }
        case V4L2_CID_FOCUS_ABSOLUTE:
            {
                return -EINVAL;
            }
        case V4L2_CID_FOCUS_RELATIVE:
            {
                return -EINVAL;
            }
        case V4L2_CID_FLASH:
            {
                ext_ctrl->value = sensor->info_priv.flash;
                break;
            }
        default :
            break;
    }
    return 0;
}
static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_control *ext_ctrl)
{
    const struct v4l2_queryctrl *qctrl;
    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
    struct sensor *sensor = to_sensor(client);
    int val_offset;

    qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);

    if (!qctrl)
    {
        SENSOR_TR("\n %s ioctrl id = 0x%x  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
        return -EINVAL;
    }

	val_offset = 0;
    switch (ext_ctrl->id)
    {
#if CONFIG_SENSOR_Scene
        case V4L2_CID_SCENE:
            {
                if (ext_ctrl->value != sensor->info_priv.scene)
                {
                    if (sensor_set_scene(icd, qctrl,ext_ctrl->value) != 0)
                        return -EINVAL;
                    sensor->info_priv.scene = ext_ctrl->value;
                }
                break;
            }
#endif
#if CONFIG_SENSOR_Effect
        case V4L2_CID_EFFECT:
            {
                if (ext_ctrl->value != sensor->info_priv.effect)
                {
                    if (sensor_set_effect(icd, qctrl,ext_ctrl->value) != 0)
                        return -EINVAL;
                    sensor->info_priv.effect= ext_ctrl->value;
                }
                break;
            }
#endif
#if CONFIG_SENSOR_DigitalZoom
        case V4L2_CID_ZOOM_ABSOLUTE:
            {
                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
                    return -EINVAL;

                if (ext_ctrl->value != sensor->info_priv.digitalzoom)
                {
                    val_offset = ext_ctrl->value -sensor->info_priv.digitalzoom;

                    if (sensor_set_digitalzoom(icd, qctrl,&val_offset) != 0)
                        return -EINVAL;
                    sensor->info_priv.digitalzoom += val_offset;

                    SENSOR_DG("%s digitalzoom is %x\n",SENSOR_NAME_STRING(),  sensor->info_priv.digitalzoom);
                }

                break;
            }
        case V4L2_CID_ZOOM_RELATIVE:
            {
                if (ext_ctrl->value)
                {
                    if (sensor_set_digitalzoom(icd, qctrl,&ext_ctrl->value) != 0)
                        return -EINVAL;
                    sensor->info_priv.digitalzoom += ext_ctrl->value;

                    SENSOR_DG("%s digitalzoom is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.digitalzoom);
                }
                break;
            }
#endif
#if CONFIG_SENSOR_Focus
        case V4L2_CID_FOCUS_ABSOLUTE:
            {
                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
                    return -EINVAL;

				if (sensor_set_focus_absolute(icd, qctrl,ext_ctrl->value) == 0) {
					if (ext_ctrl->value == qctrl->minimum) {
						sensor->info_priv.auto_focus = SENSOR_AF_MODE_INFINITY;
					} else if (ext_ctrl->value == qctrl->maximum) {
						sensor->info_priv.auto_focus = SENSOR_AF_MODE_MACRO;
					} else {
						sensor->info_priv.auto_focus = SENSOR_AF_MODE_FIXED;
					}
				}

                break;
            }
        case V4L2_CID_FOCUS_RELATIVE:
            {
                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
                    return -EINVAL;

                sensor_set_focus_relative(icd, qctrl,ext_ctrl->value);
                break;
            }
		case V4L2_CID_FOCUS_AUTO:
			{
				if (ext_ctrl->value == 1) {
					if (sensor_set_focus_mode(icd, qctrl,SENSOR_AF_MODE_AUTO) != 0)
						return -EINVAL;
					sensor->info_priv.auto_focus = SENSOR_AF_MODE_AUTO;
				} else if (SENSOR_AF_MODE_AUTO == sensor->info_priv.auto_focus){
					if (ext_ctrl->value == 0)
						sensor->info_priv.auto_focus = SENSOR_AF_MODE_CLOSE;
				}
				break;
			}
		case V4L2_CID_FOCUS_CONTINUOUS:
			{
				if (SENSOR_AF_MODE_CONTINUOUS != sensor->info_priv.auto_focus) {
					if (ext_ctrl->value == 1) {
						if (sensor_set_focus_mode(icd, qctrl,SENSOR_AF_MODE_CONTINUOUS) != 0)
							return -EINVAL;
						sensor->info_priv.auto_focus = SENSOR_AF_MODE_CONTINUOUS;
					}
				} else {
					if (ext_ctrl->value == 0)
						sensor->info_priv.auto_focus = SENSOR_AF_MODE_CLOSE;
				}
				break;
			}
#endif
#if CONFIG_SENSOR_Flash
        case V4L2_CID_FLASH:
            {
                if (sensor_set_flash(icd, qctrl,ext_ctrl->value) != 0)
                    return -EINVAL;
                sensor->info_priv.flash = ext_ctrl->value;
                break;
            }
#endif
        default:
            break;
    }

    return 0;
}

static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct soc_camera_device *icd = client->dev.platform_data;
    int i, error_cnt=0, error_idx=-1;
    
    SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());


    for (i=0; i<ext_ctrl->count; i++) {
        if (sensor_g_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
            error_cnt++;
            error_idx = i;
        }
    }

    if (error_cnt > 1)
        error_idx = ext_ctrl->count;

    if (error_idx != -1) {
        ext_ctrl->error_idx = error_idx;
        return -EINVAL;
    } else {
        return 0;
    }
}

static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct soc_camera_device *icd = client->dev.platform_data;
    int i, error_cnt=0, error_idx=-1;    
    //printk("%s,line=%d,ext_ctrl->count=%d\n",__FUNCTION__,__LINE__,ext_ctrl->count);
    for (i=0; i<ext_ctrl->count; i++) {
        if (sensor_s_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
            error_cnt++;
            error_idx = i;
        }
    }

    if (error_cnt > 1)
        error_idx = ext_ctrl->count;

    if (error_idx != -1) {
        ext_ctrl->error_idx = error_idx;
        return -EINVAL;
    } else {
        return 0;
    }
}

static int sensor_s_stream(struct v4l2_subdev *sd, int enable)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct sensor *sensor = to_sensor(client);

	if (enable == 1) {
		sensor->info_priv.enable = 1;
	} else if (enable == 0) {
		sensor->info_priv.enable = 0;
	}

	return 0;
}

/* Interface active, can use i2c. If it fails, it can indeed mean, that
 * this wasn't our capture interface, so, we wait for the right one */
static int sensor_video_probe(struct soc_camera_device *icd,
			       struct i2c_client *client)
{
    int ret,pid = 0;
    struct sensor *sensor = to_sensor(client);
    #if (SENSOR_RESET_REG != SEQUENCE_END)
    struct reginfo reg_info;
    #endif
        SENSOR_DG("\n%s..%s..%d..\n",__FUNCTION__,__FILE__,__LINE__);

    /* We must have a parent by now. And it cannot be a wrong one.
     * So this entire test is completely redundant. */
    if (!icd->dev.parent ||
	    to_soc_camera_host(icd->dev.parent)->nr != icd->iface)
		return -ENODEV;

	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
		ret = -ENODEV;
		goto sensor_video_probe_err;
	}
    /* soft reset */
#if (SENSOR_RESET_REG != SEQUENCE_END)
	reg_info.reg = SENSOR_RESET_REG;
	reg_info.val = SENSOR_RESET_VAL;
	reg_info.reg_len = SENSOR_RESET_REG_LEN;
    ret = sensor_write(client, &reg_info);
    if (ret != 0) {
        SENSOR_TR("%s soft reset sensor failed\n",SENSOR_NAME_STRING());
        ret = -ENODEV;
		goto sensor_video_probe_err;
    }
    mdelay(100);  //delay 5 microseconds
#endif
//printk("%s,%d\n",__FUNCTION__,__LINE__);

	/* check if it is an sensor sensor */
#if (SENSOR_ID_REG != SEQUENCE_END)
    ret = sensor_read(client, SENSOR_ID_REG, &pid);
    if (ret != 0) {
        SENSOR_TR("read chip id failed\n");
        ret = -ENODEV;
        goto sensor_video_probe_err;
    }
//printk("%s,%d,pid=0x%x\n",__FUNCTION__,__LINE__,pid);

    SENSOR_DG("\n %s  pid = 0x%x \n", SENSOR_NAME_STRING(), pid);
#else
	pid = SENSOR_ID;
#endif
    if (pid == SENSOR_ID) {
        sensor->model = SENSOR_V4L2_IDENT;
    } else {
        SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
        ret = -ENODEV;
        goto sensor_video_probe_err;
    }


    return 0;

sensor_video_probe_err:

    return ret;
}
static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct soc_camera_device *icd = client->dev.platform_data;
    struct sensor *sensor = to_sensor(client);
    int ret = 0;
    #if CONFIG_SENSOR_Flash	
    int i;
    #endif
    
	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
	switch (cmd)
	{
		case RK29_CAM_SUBDEV_DEACTIVATE:
		{
			sensor_deactivate(client);
			break;
		}
		case RK29_CAM_SUBDEV_IOREQUEST:
		{
			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
            if (sensor->sensor_io_request != NULL) { 
                sensor->sensor_gpio_res = NULL;
                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
                    }
                }
                if (sensor->sensor_gpio_res == NULL) {
                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
                    ret = -EINVAL;
                    goto sensor_ioctl_end;
                }
            } else {
                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                ret = -EINVAL;
                goto sensor_ioctl_end;
            }
            /* ddl@rock-chips.com : if gpio_flash havn't been set in board-xxx.c, sensor driver must notify is not support flash control 
               for this project */
            #if CONFIG_SENSOR_Flash	
        	if (sensor->sensor_gpio_res) {
                if (sensor->sensor_gpio_res->gpio_flash == INVALID_GPIO) {
                    for (i = 0; i < icd->ops->num_controls; i++) {
                		if (V4L2_CID_FLASH == icd->ops->controls[i].id) {
                			//memset((char*)&icd->ops->controls[i],0x00,sizeof(struct v4l2_queryctrl));  
                              sensor_controls[i].id=0xffff;         			
                		}
                    }
                    sensor->info_priv.flash = 0xff;
                }else{ //two cameras are the same,need to deal diffrently ,zyc
                    for (i = 0; i < icd->ops->num_controls; i++) {
                           if(0xffff == icd->ops->controls[i].id){
                              sensor_controls[i].id=V4L2_CID_FLASH;
                           }               
                    }
                }
        	}
            #endif
			break;
		}
		default:
		{
			SENSOR_TR("%s %s cmd(0x%x) is unknown !\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
			break;
		}
	}
sensor_ioctl_end:
	return ret;

}
static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
			    enum v4l2_mbus_pixelcode *code)
{
	if (index >= ARRAY_SIZE(sensor_colour_fmts))
		return -EINVAL;

	*code = sensor_colour_fmts[index].code;
	return 0;
}
static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
	.init		= sensor_init,
	.g_ctrl		= sensor_g_control,
	.s_ctrl		= sensor_s_control,
	.g_ext_ctrls          = sensor_g_ext_controls,
	.s_ext_ctrls          = sensor_s_ext_controls,
	.g_chip_ident	= sensor_g_chip_ident,
	.ioctl = sensor_ioctl,
};
static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {
	.s_mbus_fmt	= sensor_s_fmt,
	.g_mbus_fmt	= sensor_g_fmt,
	.try_mbus_fmt	= sensor_try_fmt,
	.enum_mbus_fmt	= sensor_enum_fmt,
	.s_stream   = sensor_s_stream,
};

static struct v4l2_subdev_ops sensor_subdev_ops = {
	.core	= &sensor_subdev_core_ops,
	.video = &sensor_subdev_video_ops,
};

static int sensor_probe(struct i2c_client *client,
			 const struct i2c_device_id *did)
{
    struct sensor *sensor;
    struct soc_camera_device *icd = client->dev.platform_data;
    struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
    struct soc_camera_link *icl;
    int ret;

    SENSOR_DG("\nSeven %s..%s..%d..client->addr:%d\n",__FUNCTION__,__FILE__,__LINE__,client->addr);
    if (!icd) {
        dev_err(&client->dev, "%s: missing soc-camera data!\n",SENSOR_NAME_STRING());
        return -EINVAL;
    }

    icl = to_soc_camera_link(icd);
    if (!icl) {
        dev_err(&client->dev, "%s driver needs platform data\n", SENSOR_NAME_STRING());
        return -EINVAL;
    }

    if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
        dev_warn(&adapter->dev,
        	 "I2C-Adapter doesn't support I2C_FUNC_I2C\n");
        return -EIO;
    }

    sensor = kzalloc(sizeof(struct sensor), GFP_KERNEL);
    if (!sensor)
        return -ENOMEM;

    v4l2_i2c_subdev_init(&sensor->subdev, client, &sensor_subdev_ops);

    /* Second stage probe - when a capture adapter is there */
    icd->ops		= &sensor_ops;
    sensor->info_priv.fmt = sensor_colour_fmts[0];
	#if CONFIG_SENSOR_I2C_NOSCHED
	atomic_set(&sensor->tasklock_cnt,0);
	#endif

    ret = sensor_video_probe(icd, client);
    if (ret < 0) {
        icd->ops = NULL;
        i2c_set_clientdata(client, NULL);
        kfree(sensor);
		sensor = NULL;
    }
	hrtimer_init(&(flash_off_timer.timer), CLOCK_MONOTONIC, HRTIMER_MODE_REL);
    SENSOR_DG("\n%s..%s..%d  ret = %x \n",__FUNCTION__,__FILE__,__LINE__,ret);
    return ret;
}

static int sensor_remove(struct i2c_client *client)
{
    struct sensor *sensor = to_sensor(client);
    struct soc_camera_device *icd = client->dev.platform_data;

	#if CONFIG_SENSOR_Focus
	if (sensor->sensor_wq) {
		destroy_workqueue(sensor->sensor_wq);
		sensor->sensor_wq = NULL;
	}
	#endif

    icd->ops = NULL;
    i2c_set_clientdata(client, NULL);
    client->driver = NULL;
    kfree(sensor);
	sensor = NULL;
    return 0;
}

static const struct i2c_device_id sensor_id[] = {
	{SENSOR_NAME_STRING(), 0 },
	{ }
};
MODULE_DEVICE_TABLE(i2c, sensor_id);

static struct i2c_driver sensor_i2c_driver = {
	.driver = {
		.name = SENSOR_NAME_STRING(),
	},
	.probe		= sensor_probe,
	.remove		= sensor_remove,
	.id_table	= sensor_id,
};

static int __init sensor_mod_init(void)
{
    SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());
    return i2c_add_driver(&sensor_i2c_driver);
}

static void __exit sensor_mod_exit(void)
{
    SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());
    i2c_del_driver(&sensor_i2c_driver);
}

device_initcall_sync(sensor_mod_init);
module_exit(sensor_mod_exit);

MODULE_DESCRIPTION(SENSOR_NAME_STRING(Camera sensor driver));
MODULE_AUTHOR("ddl <kernel@rock-chips>");
MODULE_LICENSE("GPL");


